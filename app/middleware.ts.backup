import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs';

// Define ALL public routes and paths that don't require authentication
const PUBLIC_PATHS = [
  // Auth routes
  '/login',
  '/logout',
  '/register',
  '/auth/callback',
  '/api/auth/callback',
  
  // API routes
  '/api/ping',
  '/api/public-test',
  '/api/public/status',
  '/api/auth/check',
  '/api/analyze-meal',
  '/api/analyze-meal/*',
  '/api/meals',
  '/api/meals/*',
  '/api/test-meal-fix',
  
  // Public pages
  '/',
  '/about',
  '/privacy',
  '/terms',
  '/test-upload.html',
  '/basic-login.html',
  '/test-meal-save',
  '/emergency-entry.html',
  '/test-upload-fix.html',
  '/test-ui.html',
  '/api-test.html',
  '/status-check.html',
  '/api-checker.html',
  '/analysis',
  '/analysis/*',
  
  // Static assets and scripts
  '/bypass-meal-analysis.js',
  '/fix-auth-cookies.js',
  '/fix-upload-progress.js',
  '/fix-all-routes.js',
  '/auth-debug.js',
  '/clean-app-state.js',
  '/fix-image-analysis.js',
  '/reset-profile-state.js',
  '/fix-meal-url.js',
  '/fix-meal-analysis.js',
  '/profile-fix.js',
  '/profile-debug.js',
  '/fix-analysis-errors.js',
  '/meal-analysis-fallback.js',
  '/fix-meal-profile-connection.js',
  '/debug-image-upload.js',
  '/verify-auth-status.js',
  '/fix-auth-detection.js',
  '/fix-gpt4o-errors.js',
  '/test-gpt4o.js',
  '/fix-env-errors.js',
  '/debug-env.js',
  '/fix-ui-styles.js',
  '/fix-auth-glitch.js',
  '/emergency-fix.js',
  '/fix-loader.js',
  '/fix-meal-data-saving.js',
  '/fix-initialization-glitch.js',
  '/fix-analysis-routes.js',
  '/fix-analysis-page.js',
  '/test-api-access.js',
  '/fix-middleware.js',
  '/fix-analysis-urls.js',
  '/fix-meal-cache.js',
  '/meal-analysis-recovery.js',
  
  // Images
  '/placeholder-meal.jpg',
  
  // Recovery and debugging
  '/meal-debug.html',
  '/TROUBLESHOOTING.html',
  '/.well-known',
  '/favicon.ico',
  '/robots.txt'
];

// Define file extensions that are always public
const PUBLIC_EXTENSIONS = [
  '.js',
  '.css',
  '.jpg',
  '.jpeg',
  '.png',
  '.ico',
  '.svg',
  '.gif',
  '.woff',
  '.woff2',
  '.ttf',
  '.eot',
  '.html'
];

// Simple middleware for authentication control
export async function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;
  
  // Remove trailing slashes for consistent matching
  const normalizedPath = pathname.endsWith('/') ? pathname.slice(0, -1) : pathname;
  
  // Log the requested path for debugging
  console.log(`[Middleware] Processing path: ${pathname}`);

  // OVERRIDE: Force allow specific critical API endpoints with no redirects
  if (normalizedPath === '/api/ping' || 
      normalizedPath.startsWith('/api/public/') || 
      normalizedPath.startsWith('/api/analyze-meal') ||
      normalizedPath.startsWith('/api/meals/')) {
    console.log(`[Middleware] Skipping auth check for API route: ${pathname}`);
    return NextResponse.next();
  }

  // Check for bypass headers
  const hasBypassHeaders = 
    req.headers.get('X-Client-Fix') === 'true' ||
    req.headers.get('X-Bypass-Middleware') === 'true' ||
    req.headers.get('X-Debug-Mode') === 'true' ||
    req.headers.get('X-Emergency-Recovery') === 'true';
    
  if (hasBypassHeaders) {
    console.log(`[Middleware] Bypass headers detected for: ${pathname}`);
    return NextResponse.next();
  }
  
  // Skip authentication for _next/static files and favicon
  if (pathname.startsWith('/_next') || 
      pathname.startsWith('/favicon.ico')) {
    return NextResponse.next();
  }
  
  // Check for analysis paths - direct allow without auth
  if (normalizedPath.startsWith('/analysis/')) {
    console.log(`[Middleware] Skipping auth check for analysis path: ${pathname}`);
    return NextResponse.next();
  }
  
  // Check if the path matches any public paths
  for (const publicPath of PUBLIC_PATHS) {
    // Check for exact match
    if (publicPath === normalizedPath) {
      console.log(`[Middleware] Skipping auth check for public route: ${pathname}`);
      return NextResponse.next();
    }
    
    // Check for path prefix with wildcard (for paths ending with *)
    if (publicPath.endsWith('*')) {
      const basePublicPath = publicPath.slice(0, -1); // Remove the * at the end
      if (normalizedPath.startsWith(basePublicPath)) {
        console.log(`[Middleware] Skipping auth check for public wildcard route: ${pathname}`);
        return NextResponse.next();
      }
    }
    
    // Check for dynamic segment route matches (like /api/meals/[id])
    if (publicPath.includes('[') && publicPath.includes(']')) {
      const routeParts = publicPath.split('/');
      const pathParts = normalizedPath.split('/');
      
      // Check if route segments match
      if (routeParts.length === pathParts.length) {
        let matches = true;
        for (let i = 0; i < routeParts.length; i++) {
          const routePart = routeParts[i];
          if (routePart.startsWith('[') && routePart.endsWith(']')) {
            // This is a dynamic segment, always matches
            continue;
          }
          if (routePart !== pathParts[i]) {
            matches = false;
            break;
          }
        }
        
        if (matches) {
          console.log(`[Middleware] Skipping auth check for dynamic route match: ${pathname}`);
          return NextResponse.next();
        }
      }
    }
  }
  
  // Special case for API routes that should be public
  if (normalizedPath.startsWith('/api/ping') || 
      normalizedPath.startsWith('/api/public') || 
      normalizedPath.includes('/status') ||
      normalizedPath.startsWith('/api/auth/check')) {
    console.log(`[Middleware] Skipping auth check for public API: ${pathname}`);
    return NextResponse.next();
  }
  
  // Check file extensions for public static assets
  if (PUBLIC_EXTENSIONS.some(ext => normalizedPath.endsWith(ext))) {
    console.log(`[Middleware] Skipping auth check for public asset: ${pathname}`);
    return NextResponse.next();
  }
  
  // For everything else, verify authentication
  const res = NextResponse.next();
  const supabase = createMiddlewareClient({ req, res });
  
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      // Redirect to login if not authenticated
      console.log(`[Middleware] Unauthenticated redirect: ${pathname} -> /login`);
      const redirectUrl = new URL('/login', req.url);
      redirectUrl.searchParams.set('return_to', pathname);
      return NextResponse.redirect(redirectUrl);
    }
    
    // User is authenticated, allow access
    console.log(`[Middleware] Authenticated access: ${pathname} (User: ${session.user.id})`);
    return res;
  } catch (error) {
    console.error(`[Middleware] Auth error: ${error}`);
    // On auth errors, just proceed rather than potentially creating a redirect loop
    return NextResponse.next();
  }
}

// Configure middleware to run on specific paths
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
}; 