import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { saveMealToHistory } from '@/lib/meal-data';
import { v4 as uuidv4 } from 'uuid';
import { REALISTIC_MEAL_DATA } from './mock-data';
import OpenAI from 'openai';
import crypto from 'crypto';
import { createClient } from '@supabase/supabase-js';
import { randomUUID } from 'crypto';
import { Database } from '@/types/supabase';
import { calculateDVPercent } from '@/lib/profile-utils';
import { SupabaseClient } from '@supabase/supabase-js';
import { safeUpdateProgress } from '@/lib/api-helpers';
import { generateMealInsights } from '../../lib/insights-generator';

/**
 * IMPORTANT: This file was causing a 'setUploadProgress is not defined' reference error
 * in the POST function (around line 1793). This was happening because:
 * 
 * 1. The server-side API code was trying to call setUploadProgress directly 
 * 2. This function only exists in the client-side browser context
 * 3. When running server-side in the API route, the function doesn't exist
 * 
 * The fix is to:
 * 1. Use safeUpdateProgress from api-helpers.ts instead of direct calls
 * 2. Remove references to direct setUploadProgress calls
 * 3. Ensure client-side scripts (fix-upload-progress.js and fix-all-routes.js) 
 *    provide a global fallback on the client side
 */

// Safe progress update function for server-side
// function safeServerProgress(message) {
//   try {
//     console.log(`[API Progress] ${message}`);
//     // In server context, setUploadProgress doesn't exist
//   } catch (e) {
//     // Silently handle any errors
//   }
// }

// Simple user profile utility function to replace the missing import
const getUserProfile = async (userId: string) => {
  try {
    // Get Supabase client
    const cookieStore = cookies();
    const supabase = createRouteHandlerClient({ cookies: () => cookieStore });
    
    // First check the profiles table
    const { data: profileData, error: profileError } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .single();
      
    if (profileError && profileError.code !== 'PGRST116') { // Not found error is ok
      console.error('Error fetching profile data from table:', profileError);
    }
    
    // Also get user metadata from auth table
    const { data: userData, error: userError } = await supabase.auth.getUser(userId);
    
    if (userError) {
      console.error('Error fetching user metadata:', userError);
    }
    
    // Combine user metadata and profile data with defaults
    const defaultProfileValues = {
      age: 35,
      gender: 'not-specified',
      height: '5\'10"',
      weight: 70,
      dietaryPreferences: null,
      healthGoals: 'General Wellness',
      activityLevel: 'Moderate',
    };
    
    const userMetadata = userData?.user?.user_metadata || {};
    const profile = profileData || {};
    
    const combinedProfile = {
      ...defaultProfileValues,
      ...profile,
      ...userMetadata,
    };
    
    console.log('Retrieved combined user profile:', {
      hasAge: !!combinedProfile.age,
      hasGender: !!combinedProfile.gender,
      hasHeight: !!combinedProfile.height,
      hasWeight: !!combinedProfile.weight,
      healthGoals: combinedProfile.healthGoals || combinedProfile.defaultGoal || 'General Wellness',
    });
    
    return combinedProfile;
  } catch (error) {
    console.error('Exception in getUserProfile:', error);
    return null;
  }
};

// Customize fallback meal based on health goal
function getCustomizedFallbackMeal(goal: string, imageUrl: string, userProfile: any): AnalysisResult {
  // Use the mock data as a base
  const mockData = REALISTIC_MEAL_DATA;
  
  // Ensure we have a valid imageUrl
  const validImageUrl = imageUrl || 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII=';
  
  // Create a properly structured result matching the AnalysisResult interface
  const result: AnalysisResult = {
    imageUrl: validImageUrl,
    mealName: mockData.caption,
    goal: goal || "General Wellness",
    mealDescription: mockData.caption,
    mealContents: mockData.foodItems.map(item => ({ name: item.name })),
    ingredients: mockData.foodItems,
    analysis: {
      calories: mockData.analysis.totalCalories,
      totalCalories: mockData.analysis.totalCalories,
      macronutrients: mockData.analysis.macronutrients.map(macro => ({
        name: macro.name,
        amount: macro.amount,
        unit: macro.unit,
        percentDailyValue: macro.dailyValuePercent,
        description: `${macro.name} provides ${macro.dailyValuePercent}% of daily needs`
      })),
      micronutrients: mockData.analysis.micronutrients.map(micro => ({
        name: micro.name,
        amount: micro.amount,
        unit: micro.unit,
        percentDailyValue: micro.dailyValuePercent,
        description: `${micro.name} provides ${micro.dailyValuePercent}% of daily needs`
      })),
      phytonutrients: [],
      benefits: mockData.analysis.benefits,
      concerns: mockData.analysis.concerns
    },
    benefits: mockData.analysis.benefits,
    concerns: mockData.analysis.concerns,
    suggestions: mockData.analysis.suggestions,
    isEstimated: true,
    success: true
  };

  console.log('[FALLBACK] Personalizing meal data based on user profile:', {
    goal: userProfile?.healthGoals || goal,
    age: userProfile?.age,
    sex: userProfile?.gender,
    weight: userProfile?.weight
  });

  return result;
}

// Group micronutrients for better organization
function categorizeMicronutrients(micronutrients) {
  const categories = {
    "Vitamins": [],
    "Minerals": [],
    "Antioxidants": [],
    "Essential Fatty Acids": []
  };
  
  if (!micronutrients || !Array.isArray(micronutrients)) {
    console.warn('[API] Micronutrients is not a valid array:', typeof micronutrients);
    return categories;
  }
  
  micronutrients.forEach(nutrient => {
    if (!nutrient || typeof nutrient !== 'object' || !nutrient.name) {
      console.warn('[API] Invalid nutrient object in micronutrients array:', nutrient);
      return; // Skip this item
    }
    
    const name = nutrient.name.toLowerCase();
    
    if (name.includes('vitamin')) {
      categories["Vitamins"].push(nutrient);
    } else if (
      name.includes('calcium') || 
      name.includes('iron') || 
      name.includes('zinc') || 
      name.includes('magnesium') || 
      name.includes('potassium') || 
      name.includes('sodium') || 
      name.includes('selenium') || 
      name.includes('copper') || 
      name.includes('manganese') || 
      name.includes('phosphorus') || 
      name.includes('iodine')
    ) {
      categories["Minerals"].push(nutrient);
    } else if (
      name.includes('flavonoid') || 
      name.includes('carotenoid') || 
      name.includes('lycopene') || 
      name.includes('lutein') || 
      name.includes('resveratrol') || 
      name.includes('anthocyanin') || 
      name.includes('polyphenol')
    ) {
      categories["Antioxidants"].push(nutrient);
    } else if (
      name.includes('omega') || 
      name.includes('dha') || 
      name.includes('epa') || 
      name.includes('ala') || 
      name.includes('fatty acid')
    ) {
      categories["Essential Fatty Acids"].push(nutrient);
    } else {
      // Default to vitamins if we can't categorize
      categories["Vitamins"].push(nutrient);
    }
  });
  
  // Remove empty categories
  Object.keys(categories).forEach(key => {
    if (categories[key].length === 0) {
      delete categories[key];
    }
  });
  
  return categories;
}

// Calculate personalized daily nutrient targets based on user profile
function calculatePersonalizedDailyValues(profile: any) {
  if (!profile) {
    return {
      // Default values for a moderately active adult
      calories: 2000,
      protein: { grams: 50, dv_percent: 100 },
      fat: { grams: 65, dv_percent: 100 },
      carbohydrates: { grams: 300, dv_percent: 100 },
      fiber: { grams: 28, dv_percent: 100 },
      vitaminA: { mcg: 900, dv_percent: 100 },
      vitaminC: { mg: 90, dv_percent: 100 },
      calcium: { mg: 1300, dv_percent: 100 },
      iron: { mg: 18, dv_percent: 100 },
      potassium: { mg: 4700, dv_percent: 100 }
    };
  }
  
  // Extract basic profile information
  const gender = profile.gender?.toLowerCase() || 'not-specified';
  const age = profile.age || 35;
  const weightKg = profile.weight || 70; // Default to 70kg if not specified
  const heightCm = profile.height || 170; // Default to 170cm if not specified
  const activityLevel = profile.activity_level?.toLowerCase() || profile.activityLevel?.toLowerCase() || 'moderate';
  const goal = profile.goal?.toLowerCase() || 'general wellness';
  
  // Calculate BMR using Mifflin-St Jeor Equation
  let bmr = 0;
  if (gender === 'male') {
    bmr = 10 * weightKg + 6.25 * heightCm - 5 * age + 5;
  } else if (gender === 'female') {
    bmr = 10 * weightKg + 6.25 * heightCm - 5 * age - 161;
  } else {
    // For non-binary or unspecified, take the average
    const maleBmr = 10 * weightKg + 6.25 * heightCm - 5 * age + 5;
    const femaleBmr = 10 * weightKg + 6.25 * heightCm - 5 * age - 161;
    bmr = (maleBmr + femaleBmr) / 2;
  }
  
  // Activity level multipliers
  const activityMultipliers = {
    'sedentary': 1.2,
    'light': 1.375,
    'moderate': 1.55,
    'active': 1.725,
    'very active': 1.9
  };
  
  // Find the closest matching activity level
  let activityMultiplier = 1.55; // Default to moderate
  Object.entries(activityMultipliers).forEach(([level, multiplier]) => {
    if (activityLevel.includes(level)) {
      activityMultiplier = multiplier;
    }
  });
  
  // Calculate daily calorie needs
  let dailyCalories = Math.round(bmr * activityMultiplier);
  
  // Adjust calories based on goal
  if (goal.includes('weight loss') || goal.includes('lose weight')) {
    dailyCalories = Math.round(dailyCalories * 0.85); // 15% deficit
  } else if (goal.includes('gain') || goal.includes('muscle') || goal.includes('bulk')) {
    dailyCalories = Math.round(dailyCalories * 1.1); // 10% surplus
  }
  
  // Calculate macronutrient distribution based on goal
  let proteinRatio = 0.2; // 20% of calories from protein
  let fatRatio = 0.3;     // 30% of calories from fat
  let carbRatio = 0.5;    // 50% of calories from carbs
  
  // Adjust macro ratios based on goal
  if (goal.includes('muscle') || goal.includes('strength') || goal.includes('athletic')) {
    proteinRatio = 0.3;  // Higher protein for muscle building
    carbRatio = 0.45;    // Moderate carbs
    fatRatio = 0.25;     // Lower fat
  } else if (goal.includes('keto') || goal.includes('low carb')) {
    proteinRatio = 0.3;  // Moderate protein
    fatRatio = 0.6;      // High fat
    carbRatio = 0.1;     // Very low carb
  } else if (goal.includes('endurance') || goal.includes('cardio') || goal.includes('running')) {
    carbRatio = 0.6;     // Higher carbs for endurance
    proteinRatio = 0.2;  // Moderate protein
    fatRatio = 0.2;      // Lower fat
  }
  
  // Calculate grams per macronutrient
  // Protein & carbs = 4 calories per gram, fat = 9 calories per gram
  const proteinGrams = Math.round((dailyCalories * proteinRatio) / 4);
  const carbGrams = Math.round((dailyCalories * carbRatio) / 4);
  const fatGrams = Math.round((dailyCalories * fatRatio) / 9);
  
  // Calculate fiber based on calorie intake (14g per 1000 calories is a good guideline)
  const fiberGrams = Math.round((dailyCalories / 1000) * 14);
  
  // Vitamins and minerals - adjust based on age & gender
  // These are simplified and should be replaced with more detailed calculations
  // based on national dietary guidelines for different demographics
  
  // Base values
  let vitaminA = 900; // mcg RAE
  let vitaminC = 90;  // mg
  let calcium = 1000; // mg
  let iron = 18;      // mg
  let potassium = 4700; // mg
  
  // Adjust for gender differences
  if (gender === 'female') {
    vitaminA = 700;  // Women generally need less vitamin A
    vitaminC = 75;   // Women generally need less vitamin C
    iron = 18;       // Women generally need more iron (especially in childbearing years)
  } else if (gender === 'male') {
    iron = 8;        // Men need less iron
  }
  
  // Adjust for age
  if (age > 50) {
    calcium = 1200;  // Older adults need more calcium
    // No need to set vitaminD, it's not in our return object
  } else if (age < 19) {
    calcium = 1300;  // Teenagers need more calcium
  }
  
  return {
    calories: dailyCalories,
    protein: { grams: proteinGrams, dv_percent: 100 },
    carbohydrates: { grams: carbGrams, dv_percent: 100 },
    fat: { grams: fatGrams, dv_percent: 100 },
    fiber: { grams: fiberGrams, dv_percent: 100 },
    vitaminA: { mcg: vitaminA, dv_percent: 100 },
    vitaminC: { mg: vitaminC, dv_percent: 100 },
    calcium: { mg: calcium, dv_percent: 100 },
    iron: { mg: iron, dv_percent: 100 },
    potassium: { mg: potassium, dv_percent: 100 }
  };
}

// Interface for the analysis result
interface AnalysisResult {
  id?: string;               // ID for the analysis record
  imageUrl: string;
  mealName: string;
  goal: string;
  mealDescription?: string;
  mealContents: Array<{name: string}>;
  ingredients: Array<{name: string; portion?: string; calories?: number}>;
  analysis: {
    calories: number;
    totalCalories: number;
    macronutrients: Array<{
      name: string;
      amount: number;
      unit: string;
      percentDailyValue?: number;
      description?: string;
    }>;
    micronutrients: Array<{
      name: string;
      amount: number;
      unit: string;
      percentDailyValue?: number;
      description?: string;
    }>;
    phytonutrients?: Array<{
      name: string;
      amount: number;
      unit: string;
      percentDailyValue?: number;
      description?: string;
    }>;
    benefits?: string[];
    concerns?: string[];
    glycemicImpact?: string;
    inflammatoryPotential?: string;
    nutrientDensity?: string;
  };
  benefits?: string[];
  concerns?: string[];
  suggestions?: string[];
  scientificInsights?: string[];
  goalAlignment?: string;
  userProfile?: any;
  isEstimated?: boolean;
  success?: boolean;
  foodName?: string;    // Specifically detected food name from OpenAI
  detectedFood?: string; // Alternative field for frontend compatibility
  error?: string;        // Error message if analysis failed
  errorDetails?: string; // Detailed error information
  isFallback?: boolean;  // Flag to indicate if this is fallback data
}

// Add a flag to enable development mode (bypass OpenAI calls)
const DEVELOPMENT_MODE = false; // Always use OpenAI API

// Declaration for analysisResult at the right scope
let analysisResult: AnalysisResult | null = null;

// Helper function to sanitize OpenAI JSON response
function sanitizeOpenAIJsonResponse(content: string): string {
  // Remove any markdown formatting or code blocks
  let cleaned = content;
  
  // Remove markdown code blocks if present
  cleaned = cleaned.replace(/```json\s+/g, '');
  cleaned = cleaned.replace(/```\s*$/g, '');
  cleaned = cleaned.replace(/```/g, '');
  
  // Remove any explanatory text before or after the JSON
  const jsonStartIndex = cleaned.indexOf('{');
  const jsonEndIndex = cleaned.lastIndexOf('}');
  
  if (jsonStartIndex !== -1 && jsonEndIndex !== -1) {
    cleaned = cleaned.substring(jsonStartIndex, jsonEndIndex + 1);
  }
  
  return cleaned;
}

// Add a function to safely store the analysis data in cookies
function storeAnalysisResult(analysisId: string, data: any, response: NextResponse): NextResponse {
  try {
    // Store the analysis result in cookies for client-side access (not using localStorage directly)
    const sanitizedResult = JSON.stringify(data);
    
    // Store in multiple cookies for redundancy
    response.cookies.set({
      name: 'meal_analysis_data',
      value: sanitizedResult,
      maxAge: 60 * 30, // 30 minutes
      path: '/'
    });
    
    response.cookies.set({
      name: `meal_analysis_${analysisId}`,
      value: sanitizedResult,
      maxAge: 60 * 30, // 30 minutes
      path: '/'
    });
    
    return response;
  } catch (error) {
    console.error('Error storing analysis result:', error);
    return response;
  }
}

// Helper function to safely check if we're in a browser environment
function isBrowser(): boolean {
  return typeof window !== 'undefined' && typeof window.document !== 'undefined';
}

// Export GET handler with improved error handling
export async function GET(request: NextRequest) {
  try {
    // Get the URL query parameters
    const url = new URL(request.url);
    const searchParams = url.searchParams;
    const queryId = searchParams.get('id') || 'unknown';
    
    console.log(`[API GET] Received request for meal ID: ${queryId}`);
    
    // Initialize the database client
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);
    
    // Get the user ID from the session
    const userId = await getUserId(request);
    
    // Query the database for the meal
    console.log(`[API GET] Attempting to fetch meal from database with queryId: ${queryId}`);
    
    try {
      const { data: mealData, error } = await supabase
        .from('meal_analyses')
        .select('*')
        .eq('id', queryId)
        .single();
      
      if (error) {
        console.log(`[API GET] Error fetching meal_id ${queryId}:`, error);
        
        // Try a backup query
        try {
          console.log(`[API GET] Meal not found in meal_analyses table, checking alternative tables: ${queryId}`);
          
          // Try alternative query
          const { data: backupData, error: backupError } = await supabase
            .from('meals')  // Try an alternative table if it exists
            .select('*')
            .eq('id', queryId)
            .single();
            
          if (backupError) {
            console.log(`[API GET] Backup query also failed for ID: ${queryId}, error:`, backupError.message);
            
            // If the ID is in the format "meal-timestamp", it's likely a legacy format
            // In this case, provide a basic fallback response
            if (queryId.startsWith('meal-')) {
              console.log(`[API GET] Legacy meal ID format detected, providing a basic fallback response`);
              
              // Check localStorage only in browser
              if (isBrowser()) {
                // Try to look for this meal ID in localStorage
                const localData = localStorage.getItem(`meal_analysis_${queryId}`);
                if (localData) {
                  try {
                    const parsedLocalData = JSON.parse(localData);
                    return Response.json(parsedLocalData);
                  } catch (parseError) {
                    console.error('[API GET] Error parsing localStorage data:', parseError);
                  }
                }
              }
              
              // Create a basic fallback response
              return Response.json({
                id: queryId,
                name: "Analyzed Meal",
                mealName: "Analyzed Meal",
                detected_food: "Food Item",
                calories: 450,
                analysis: {
                  calories: 450,
                  macronutrients: [
                    { name: "Protein", amount: 20, unit: "g", percentDailyValue: 40 },
                    { name: "Carbohydrates", amount: 40, unit: "g", percentDailyValue: 13 },
                    { name: "Fat", amount: 15, unit: "g", percentDailyValue: 19 },
                    { name: "Fiber", amount: 5, unit: "g", percentDailyValue: 18 }
                  ],
                  micronutrients: [
                    { name: "Vitamin A", amount: 300, unit: "IU", percentDailyValue: 10 },
                    { name: "Vitamin C", amount: 15, unit: "mg", percentDailyValue: 25 },
                    { name: "Calcium", amount: 150, unit: "mg", percentDailyValue: 15 },
                    { name: "Iron", amount: 2, unit: "mg", percentDailyValue: 10 }
                  ]
                },
                fallback: true,
                legacy_id: true
              });
            }
            
            return Response.json({ error: "Meal not found", success: false }, { status: 404 });
          }
          
          return Response.json(backupData);
        } catch (alternativeErr) {
          console.error('[API GET] Error in backup query:', alternativeErr);
          return Response.json({ error: "Meal not found", success: false }, { status: 404 });
        }
      }
      
      return Response.json(mealData);
    } catch (dbError) {
      console.error('[API GET] Database error:', dbError);
      
      // Attempt to sync from localStorage but only in browser
      console.log(`[API GET] Meal not found in database, attempting to sync from localStorage: ${queryId}`);
      
      if (isBrowser()) {
        try {
          const localData = localStorage.getItem(`meal_analysis_${queryId}`);
          if (localData) {
            const parsedData = JSON.parse(localData);
            // If we have valid local data, return it
            if (parsedData && parsedData.id) {
              return Response.json(parsedData);
            }
          }
        } catch (localError) {
          console.error('[API GET] Error retrieving from localStorage:', localError);
        }
      }
      
      return Response.json({ error: "Meal not found", success: false }, { status: 404 });
    }
  } catch (err: any) {
    console.error('[API GET] Unexpected error:', err);
    return Response.json({ error: err.message || "Unknown error", success: false }, { status: 500 });
  }
}

// Helper to parse JSONB fields that might be strings or objects
function parseJsonField(field: any): any {
  if (!field) return null;
  
  if (typeof field === 'string') {
    try {
      return JSON.parse(field);
    } catch {
      return field;
    }
  }
  
  return field;
}

// Upload to Supabase storage
const uploadImageToSupabase = async (
  decodedImage: Buffer, 
  fileName: string,
  contentType: string,
  userId: string | null,
  supabaseClient: any
): Promise<string | null> => {
  console.log('Starting Supabase storage upload process...');
  
  try {
    console.log(`Decoded image: ${decodedImage.length} bytes, type: ${contentType}`);
    
    // Make sure we have a valid file extension
    if (!fileName.includes('.')) {
      fileName = `${fileName}.jpeg`;
    }
    
    // Generate a safe file name with timestamp to avoid collisions
    const timestamp = Date.now();
    let safeName = fileName.replace(/[^a-zA-Z0-9.]/g, '');
    safeName = `${timestamp}-${safeName}${crypto.randomBytes(4).toString('hex')}.jpeg`;
    
    // Use user-specific path if authenticated, otherwise use anonymous folder
    let storagePath: string;
    if (userId) {
      // User is authenticated - store in their folder
      storagePath = `users/${userId}/${safeName}`;
      console.log(`[Storage] Using authenticated user path for userId: ${userId}`);
    } else {
      // Anonymous user - store in anonymous folder with timestamp to organize
      storagePath = `anonymous/${timestamp}/${safeName}`;
      console.log('[Storage] Using anonymous path since no authenticated user was found');
    }
    
    console.log(`Uploading to Supabase path: ${storagePath}`);
    console.log(`Storage path used: ${storagePath}`);
    
    // Upload the file to Supabase Storage
    const { data, error } = await supabaseClient.storage
      .from('meal-images')
      .upload(storagePath, decodedImage, {
        contentType: contentType,
        cacheControl: "3600",
        upsert: true,
      });
    
    if (error) {
      console.error('Error uploading to Supabase storage:', error.message);
      return null;
    }
    
    // Get the public URL
    const { data: publicUrlData } = supabaseClient.storage
      .from('meal-images')
      .getPublicUrl(storagePath);
    
    const publicUrl = publicUrlData.publicUrl;
    console.log('Supabase storage upload successful:', publicUrl);
    
    return publicUrl;
  } catch (error) {
    console.error('Error in Supabase upload:', error);
    return null;
  }
};

// Get the authenticated user ID from the request headers (set by middleware)
const getUserId = async (req: NextRequest): Promise<string | null> => {
  // Track where we found auth info for better debugging
  let authSource = 'none';
  
  // 1. First check middleware headers (most reliable)
  const userId = req.headers.get('x-auth-user-id');
  const isAuthenticated = req.headers.get('x-authenticated') === 'true';
  
  if (isAuthenticated && userId) {
    console.log(`[API] Authenticated user: ${userId} (source: middleware headers)`);
    return userId;
  }
  
  // 2. Check FormData for auth info (added by fix-storage-auth.js)
  try {
    // Clone the request to not consume the body
    const clonedReq = req.clone();
    
    // Only check FormData for multipart requests
    const contentType = req.headers.get('content-type') || '';
    if (contentType.includes('multipart/form-data')) {
      try {
        const formData = await clonedReq.formData();
        const formUserId = formData.get('userId') as string;
        const formAuthFlag = formData.get('isAuthenticated') as string;
        
        if (formUserId && formAuthFlag === 'true') {
          console.log(`[API] Authenticated user: ${formUserId} (source: form data)`);
          return formUserId;
        }
      } catch (e) {
        console.error('[API] Error parsing FormData:', e);
      }
    }
  } catch (e) {
    console.error('[API] Error checking FormData for auth:', e);
  }
  
  // 3. Check the cookies for direct authentication info
  try {
    const authCookie = req.cookies.get('supabase-auth-token');
    if (authCookie?.value) {
      try {
        const tokenValue = JSON.parse(authCookie.value);
        // Extract user ID from token if possible
        if (Array.isArray(tokenValue) && tokenValue.length > 0) {
          const token = tokenValue[0];
          // Basic JWT parsing - extract payload
          const tokenParts = token.split('.');
          if (tokenParts.length === 3) {
            const payload = JSON.parse(atob(tokenParts[1]));
            if (payload.sub) {
              console.log(`[API] Authenticated user: ${payload.sub} (source: auth cookie)`);
              return payload.sub;
            }
          }
        }
      } catch (e) {
        console.error('[API] Error parsing auth cookie:', e);
      }
    }
  } catch (e) {
    console.error('[API] Error checking cookies for auth:', e);
  }
  
  // 4. Direct user ID cookie check
  try {
    const userIdCookie = req.cookies.get('supabase-auth-user-id');
    if (userIdCookie?.value) {
      console.log(`[API] Authenticated user: ${userIdCookie.value} (source: user-id cookie)`);
      return userIdCookie.value;
    }
  } catch (e) {
    console.error('[API] Error checking user ID cookie:', e);
  }

  // Use cookies to create a Supabase client and try to get the session
  try {
    const cookieStore = cookies();
    const supabase = createRouteHandlerClient({ cookies: () => cookieStore });
    const { data: { session } } = await supabase.auth.getSession();
    if (session?.user?.id) {
      console.log(`[API] Authenticated user: ${session.user.id} (source: supabase session)`);
      return session.user.id;
    }
  } catch (e) {
    console.error('[API] Error checking Supabase session:', e);
  }
  
  // We'll continue with anonymous user path
  console.log('[API] No authenticated user detected, proceeding as anonymous');
  return null;
};

// Helper function to normalize meal data format
const normalizeMealData = (data: any, id?: string): any => {
  if (!data) return { meal_name: 'Analyzed Meal' };
  
  // Create a deep copy to avoid mutating the original
  const normalized = JSON.parse(JSON.stringify(data));
  
  // Ensure ID exists
  normalized.id = id || normalized.id || `meal-${Date.now()}`;
  
  // Normalize meal name from different possible sources
  normalized.meal_name = normalized.dish_name || 
                        normalized.mealName || 
                        normalized.name ||
                        normalized.meal_name || 
                        normalized.caption ||  // Add caption as a potential source
                        'Analyzed Meal';
  
  // Ensure caption exists for backward compatibility
  normalized.caption = normalized.caption || normalized.meal_name;
  
  // Ensure calories exists
  normalized.calories = normalized.calories || 
                       (normalized.analysis && normalized.analysis.calories) ||
                       (normalized.analysis && normalized.analysis.totalCalories) ||
                       (normalized.nutrients && normalized.nutrients.calories) ||
                       0;
  
  // Normalize macronutrients 
  // Check different possible locations for macronutrients
  let macronutrients = normalized.macronutrients || 
                      (normalized.analysis && normalized.analysis.macronutrients) ||
                      (normalized.nutrients && normalized.nutrients.macronutrients) ||
                      [];
  
  // Ensure macronutrients is an array
  if (!Array.isArray(macronutrients)) {
    macronutrients = [];
  }
  
  // Ensure macronutrients is properly formatted
  normalized.macronutrients = macronutrients.map((macro: any) => ({
    name: macro.name || 'Unknown',
    amount: macro.amount || 0,
    unit: macro.unit || 'g',
    percentDailyValue: macro.percentDailyValue || macro.percentDaily || 0
  }));
  
  // Normalize micronutrients
  // Check different possible locations for micronutrients
  let micronutrients = normalized.micronutrients || 
                      (normalized.analysis && normalized.analysis.micronutrients) ||
                      (normalized.nutrients && normalized.nutrients.micronutrients) ||
                      [];
  
  // Ensure micronutrients is an array
  if (!Array.isArray(micronutrients)) {
    micronutrients = [];
  }
  
  // Ensure micronutrients is properly formatted
  normalized.micronutrients = micronutrients.map((micro: any) => ({
    name: micro.name || 'Unknown',
    amount: micro.amount || 0,
    unit: micro.unit || 'mg',
    percentDailyValue: micro.percentDailyValue || micro.percentDaily || 0
  }));
  
  // Normalize benefits, concerns, and suggestions
  normalized.benefits = Array.isArray(normalized.benefits) ? normalized.benefits : 
                      (normalized.analysis && Array.isArray(normalized.analysis.benefits)) ? normalized.analysis.benefits : [];
  
  normalized.concerns = Array.isArray(normalized.concerns) ? normalized.concerns : 
                       (normalized.analysis && Array.isArray(normalized.analysis.concerns)) ? normalized.analysis.concerns : [];
  
  normalized.suggestions = Array.isArray(normalized.suggestions) ? normalized.suggestions : 
                         (normalized.analysis && Array.isArray(normalized.analysis.suggestions)) ? normalized.analysis.suggestions : [];
  
  // Ensure analysis object exists for backward compatibility
  if (!normalized.analysis) {
    normalized.analysis = {
      calories: normalized.calories,
      totalCalories: normalized.calories,
      macronutrients: normalized.macronutrients,
      micronutrients: normalized.micronutrients,
      benefits: normalized.benefits,
      concerns: normalized.concerns,
      suggestions: normalized.suggestions
    };
  }
  
  return normalized;
};

// Add this function to add descriptions to nutrients
function addDescriptionsToNutrients(response: any): any {
  // Make a deep copy to avoid mutating the original
  const result = JSON.parse(JSON.stringify(response));
  
  // Define common descriptions for nutrients
  const descriptions = {
    protein: "Essential for muscle building, tissue repair, and overall growth.",
    carbohydrates: "Primary source of energy for the body and brain.",
    carbs: "Primary source of energy for the body and brain.",
    fat: "Important for absorbing vitamins, supporting brain health, and providing long-lasting energy.",
    fiber: "Aids digestion, helps maintain bowel health, and can reduce cholesterol.",
    sugar: "Provides quick energy but should be consumed in moderation.",
    sodium: "Helps maintain fluid balance and is needed for muscle and nerve function.",
    calcium: "Essential for strong bones, teeth, and proper muscle function.",
    iron: "Critical for oxygen transport in the blood and energy production.",
    potassium: "Helps regulate fluid balance and muscle contractions.",
    "vitamin a": "Important for vision, immune function, and cell growth.",
    "vitamin c": "Supports immune function and acts as an antioxidant.",
    "vitamin d": "Vital for calcium absorption and bone health.",
    "vitamin e": "Acts as an antioxidant and supports immune function.",
    "vitamin k": "Essential for blood clotting and bone health.",
    magnesium: "Supports muscle and nerve function and energy production.",
    zinc: "Important for immune function, wound healing, and cell division."
  };

  // Add descriptions to macronutrients
  if (result.analysis?.macronutrients) {
    result.analysis.macronutrients = result.analysis.macronutrients.map((nutrient: any) => {
      if (!nutrient.description) {
        const key = (nutrient.name || '').toLowerCase();
        nutrient.description = descriptions[key] || 
          `${nutrient.name} is an essential nutrient for overall health.`;
      }
      return nutrient;
    });
  }
  
  // Add descriptions to micronutrients
  if (result.analysis?.micronutrients) {
    result.analysis.micronutrients = result.analysis.micronutrients.map((nutrient: any) => {
      if (!nutrient.description) {
        const key = (nutrient.name || '').toLowerCase();
        nutrient.description = descriptions[key] || 
          `${nutrient.name} is an essential micronutrient for body functions.`;
      }
      return nutrient;
    });
  }
  
  return result;
}

// Process OpenAI response and apply personalized daily value calculations
const processOpenAIResponse = (data: any, userProfile: any, personalizedTargets: any): any => {
  if (!data) return null;
  
  // Deep clone to avoid mutating original data
  const processed = JSON.parse(JSON.stringify(data));
  
  // Ensure calories exists
  processed.calories = processed.calories || 0;
  
  // Process macronutrients with personalized daily values
  if (Array.isArray(processed.macronutrients)) {
    processed.macronutrients = processed.macronutrients.map((macro: any) => {
      if (!macro || !macro.name) return macro;
      
      // Create a normalized, standardized key
      const normalizedName = macro.name.toLowerCase().replace(/\s+/g, '_');
      
      // Check if we have a personalized target for this macronutrient
      let dvPercent = macro.dv_percent || macro.percentDailyValue || 0;
      
      // Calculate personalized DV if we have a target and an amount
      if (personalizedTargets && 
          personalizedTargets[normalizedName] && 
          typeof personalizedTargets[normalizedName].grams === 'number' &&
          typeof macro.amount === 'number') {
        // Calculate percentage based on personalized target
        dvPercent = Math.round((macro.amount / personalizedTargets[normalizedName].grams) * 100);
        console.log(`[API] Personalized DV for ${macro.name}: ${macro.amount}${macro.unit || 'g'} = ${dvPercent}% of ${personalizedTargets[normalizedName].grams}g target`);
      }
      
      // Ensure we have a numeric value, not null or undefined
      return {
        ...macro,
        percentDailyValue: dvPercent,
        dv_percent: dvPercent
      };
    });
  }
  
  // Process micronutrients with personalized daily values
  if (Array.isArray(processed.micronutrients)) {
    processed.micronutrients = processed.micronutrients.map((micro: any) => {
      if (!micro || !micro.name) return micro;
      
      // Handle different unit types and normalizations
      let normalizedName = micro.name.toLowerCase().replace(/\s+/g, '_');
      
      // Map micronutrient name variations to standardized keys
      const nameMapping: Record<string, string> = {
        'vitamin_c': 'vitaminC',
        'vitamin_d': 'vitaminD',
        'vitamin_a': 'vitaminA',
        'vitamin_e': 'vitaminE',
        'vitamin_b1': 'vitaminB1',
        'vitamin_b2': 'vitaminB2',
        'vitamin_b3': 'vitaminB3',
        'vitamin_b6': 'vitaminB6',
        'vitamin_b9': 'vitaminB9',
        'vitamin_b12': 'vitaminB12'
      };
      
      const targetKey = nameMapping[normalizedName] || normalizedName;
      
      // Check if we have a personalized target for this micronutrient
      let dvPercent = micro.dv_percent || micro.percentDailyValue || 0;
      
      // Calculate personalized DV if we have a target and an amount
      if (personalizedTargets && 
          personalizedTargets[targetKey] && 
          typeof micro.amount === 'number') {
        // Get the unit from both the target and the micro
        const targetUnitKey = Object.keys(personalizedTargets[targetKey])[0]; // e.g., 'mg'
        const targetAmount = personalizedTargets[targetKey][targetUnitKey];
        
        if (typeof targetAmount === 'number' && targetAmount > 0) {
          // Calculate percentage based on personalized target
          dvPercent = Math.round((micro.amount / targetAmount) * 100);
          console.log(`[API] Personalized DV for ${micro.name}: ${micro.amount}${micro.unit || targetUnitKey} = ${dvPercent}% of ${targetAmount}${targetUnitKey} target`);
        }
      }
      
      // Ensure we have a numeric value, not null or undefined
      return {
        ...micro,
        percentDailyValue: dvPercent,
        dv_percent: dvPercent
      };
    });
  }
  
  return processed;
}

// Analyze meal image using OpenAI API
async function analyzeMealImage(imageUrl: string, goal: string = "General Wellness", forceAnalysisType: string | null = null): Promise<any> {
  console.log(`[API] Analyzing image at ${imageUrl} with goal: ${goal}`);
  
  try {
    updateProgress('Initializing image analysis...');
    
    // Initialize OpenAI
    const openaiApiKey = process.env.OPENAI_API_KEY;
    if (!openaiApiKey) {
      console.warn('[API] Missing OpenAI API key, using fallback data');
      updateProgress('Using fallback data (no API key)');
      return getCustomizedFallbackMeal(goal, imageUrl, null);
    }
    
    const openai = new OpenAI({ apiKey: openaiApiKey });
    updateProgress('Processing image with AI...');
    
    // Call the OpenAI API to analyze the image
    // Initialize userProfile to prevent reference error
    let userProfile = null;
    
    // Generate a profile prompt if we have user data
    let userProfilePrompt = '';
    if (userProfile) {
      userProfilePrompt = `User profile: ${userProfile.gender || 'Person'}, ${userProfile.age || 'adult'}`;
      
      if (userProfile.weight) {
        userProfilePrompt += `, weight: ${userProfile.weight}${userProfile.weightUnit || 'lbs'}`;
      }
      
      if (userProfile.height) {
        userProfilePrompt += `, height: ${userProfile.height}${userProfile.heightUnit || 'in'}`;
      }
      
      if (userProfile.activityLevel) {
        userProfilePrompt += `, activity level: ${userProfile.activityLevel}`;
      }
      
      if (userProfile.dietaryRestrictions && userProfile.dietaryRestrictions.length > 0) {
        userProfilePrompt += `, dietary restrictions: ${userProfile.dietaryRestrictions.join(', ')}`;
      }
      
      if (userProfile.allergies && userProfile.allergies.length > 0) {
        userProfilePrompt += `, allergies: ${userProfile.allergies.join(', ')}`;
      }
    }
    
    const response = await openai.chat.completions.create({
      model: process.env.OPENAI_MODEL_GPT_VISION || 'gpt-4o',
      messages: [
        {
          role: "system",
          content: `You are a world-class nutritionist and dietitian AI with expertise in personalized nutrition science and health optimization. Analyze food images with extreme precision, providing comprehensive and personalized nutritional assessments.

For the given meal image, provide:

1. DETAILED IDENTIFICATION: Comprehensive list of all visible food items with estimated quantities, preparation methods, and ingredients.

2. COMPLETE NUTRITIONAL ANALYSIS:
   - Precise macronutrients (protein, carbs, fat, fiber) with quantities and quality assessment
   - Comprehensive micronutrients with detailed health benefits
   - Phytonutrients, antioxidants, and bioactive compounds with their health significance
   - Glycemic impact and blood sugar response estimates
   - Inflammatory potential assessment
   - Overall nutrient density score

3. PERSONALIZED INSIGHTS:
   - Health benefits specific to the user's profile and goals
   - Potential concerns based on the nutritional composition
   - Scientific health implications with references to recent research
   - Specific goal alignment analysis (weight management, muscle building, athletic performance, etc.)
   - Actionable suggestions for optimization

Structure your response as a detailed JSON object with the following fields:
{
  "mealName": "Descriptive name of the analyzed meal",
  "mealDescription": "Brief overall description",
  "detectedFood": "Primary foods detected in the image",
  "mealContents": [{"name": "Food item 1"}, {"name": "Food item 2"}],
  "ingredients": [
    {"name": "Ingredient", "portion": "Portion size", "calories": number, "notes": "Optional notes"}
  ],
  "analysis": {
    "calories": number,
    "macronutrients": [
      {"name": "Protein", "amount": number, "unit": "g", "percentDailyValue": number, "description": "Details about quality and health impact"}
    ],
    "micronutrients": [
      {"name": "Vitamin/Mineral", "amount": number, "unit": "mg/μg", "percentDailyValue": number, "description": "Detailed health benefits"}
    ],
    "phytonutrients": [
      {"name": "Phytonutrient name", "significance": "Health significance", "food_source": "Source in this meal"}
    ],
    "glycemicImpact": "Detailed assessment of glycemic impact",
    "inflammatoryPotential": "Assessment of inflammatory potential",
    "nutrientDensity": "Overall nutrient density evaluation",
    "scientificInsights": ["Scientific fact 1", "Scientific fact 2"],
    "personalized_insights": "Comprehensive personalized analysis with specific advice for the user's profile and health goals"
  },
  "benefits": ["Benefit 1", "Benefit 2"],
  "concerns": ["Concern 1", "Concern 2"],
  "suggestions": ["Suggestion 1", "Suggestion 2"],
  "goalAlignment": "How this meal aligns with specific health/fitness goals"
}

IMPORTANT: Your analysis must be extremely detailed, scientifically accurate, and personalized to the user's health goals and profile when provided. Focus on being thorough and comprehensive. Provide actionable insights, not just data.`
        },
        {
          role: "user",
          content: [
            {
              type: "text",
              text: `Please analyze this meal image in detail. The user's health goal is: "${goal}".
                
${userProfilePrompt ? `User profile information: ${userProfilePrompt}` : ""}

Provide a comprehensive nutritional analysis with personalized insights.`
            },
            {
              type: "image_url",
              image_url: {
                url: imageUrl
              }
            }
          ]
        }
      ],
      max_tokens: 4000,
      temperature: 0.5
    });
    
    // Extract and parse the response
    const content = response.choices[0]?.message?.content;
    
    if (!content) {
      throw new Error('No content returned from OpenAI');
    }
    
    updateProgress('AI analysis complete');
    updateProgress('Processing nutrition data...');
    
    try {
      // Parse the JSON response
      const analysisData = JSON.parse(content);
      
      // Format into our expected result structure
      const result: AnalysisResult = {
        success: true,
        imageUrl,
        goal,
        mealName: analysisData.mealName || 'Analyzed Meal',
        mealDescription: analysisData.mealDescription || '',
        detectedFood: analysisData.detectedFood || '',
        foodName: analysisData.detectedFood || '',
        mealContents: analysisData.mealContents || [],
        ingredients: analysisData.ingredients || [],
        analysis: {
          calories: analysisData.analysis?.calories || 0,
          totalCalories: analysisData.analysis?.calories || 0,
          macronutrients: analysisData.analysis?.macronutrients || [],
          micronutrients: analysisData.analysis?.micronutrients || [],
          phytonutrients: analysisData.analysis?.phytonutrients || [],
          glycemicImpact: analysisData.analysis?.glycemicImpact || '',
          inflammatoryPotential: analysisData.analysis?.inflammatoryPotential || '',
          nutrientDensity: analysisData.analysis?.nutrientDensity || ''
        },
        benefits: analysisData.benefits || [],
        concerns: analysisData.concerns || [],
        suggestions: analysisData.suggestions || [],
        scientificInsights: analysisData.scientificInsights || [],
        goalAlignment: analysisData.goalAlignment || '',
        isEstimated: true
      };
      
      updateProgress('Analysis complete');
      return result;
    } catch (parseError) {
      console.error('[API] Error parsing OpenAI response:', parseError);
      console.log('Raw content:', content);
      
      // Fall back to mock data
      updateProgress('Error parsing AI response, using fallback');
      return getCustomizedFallbackMeal(goal, imageUrl, null);
    }
  } catch (error) {
    console.error('[API] Error analyzing meal image:', error);
    // Use safeUpdateProgress to indicate error
    updateProgress('Error analyzing image');
    
    // Fall back to mock data
    return getCustomizedFallbackMeal(goal, imageUrl, null);
  }
}

// Fix the database saving function
export async function saveMealToDatabase(userId: string, mealData: any, imageUrl: string): Promise<{ success: boolean; mealId: string | null; error?: any }> {
  console.log('[API] Saving meal data to database for user:', userId);
  
  if (!userId) {
    console.warn('[API] No user ID provided, cannot save meal');
    return { success: false, mealId: null, error: 'No user ID provided' };
  }
  
  try {
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);
    
    // Ensure all required fields are present - fix to use correct parameter count
    const normalizedMealData = normalizeMealData(mealData);
    
    const mealId = normalizedMealData.id || mealData.mealId;
    
    // Format for database - make sure all fields match the updated schema
    const dbEntry = {
      id: mealId,
      user_id: userId,
      caption: normalizedMealData.mealName || 'Analyzed Meal',
      name: normalizedMealData.mealName || 'Analyzed Meal', // Include both name and caption
      meal_name: normalizedMealData.mealName || 'Analyzed Meal',
      description: normalizedMealData.mealDescription || 'Food analysis',
      meal_type: 'analyzed',
      goal: normalizedMealData.goal || 'General Wellness',
      detected_food: normalizedMealData.detectedFood || normalizedMealData.foodName || '',
      image_url: imageUrl,
      calories: normalizedMealData.analysis?.calories || 0,
      total_calories: normalizedMealData.analysis?.totalCalories || normalizedMealData.analysis?.calories || 0,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      personalized_insights: normalizedMealData.personalized_insights || '',
      
      // Convert to JSON strings for database - ensure proper stringification
      macronutrients: normalizedMealData.analysis?.macronutrients ? 
        JSON.stringify(normalizedMealData.analysis.macronutrients) : null,
      
      micronutrients: normalizedMealData.analysis?.micronutrients ? 
        JSON.stringify(normalizedMealData.analysis.micronutrients) : null,
      
      phytonutrients: normalizedMealData.analysis?.phytonutrients ? 
        JSON.stringify(normalizedMealData.analysis.phytonutrients) : null,
      
      ingredients: normalizedMealData.ingredients ? 
        JSON.stringify(normalizedMealData.ingredients) : null,
      
      benefits: normalizedMealData.benefits || normalizedMealData.analysis?.benefits ? 
        JSON.stringify(normalizedMealData.benefits || normalizedMealData.analysis?.benefits) : null,
      
      concerns: normalizedMealData.concerns || normalizedMealData.analysis?.concerns ? 
        JSON.stringify(normalizedMealData.concerns || normalizedMealData.analysis?.concerns) : null,
      
      suggestions: normalizedMealData.suggestions || normalizedMealData.analysis?.suggestions ? 
        JSON.stringify(normalizedMealData.suggestions || normalizedMealData.analysis?.suggestions) : null,
        
      scientific_insights: normalizedMealData.scientificInsights || normalizedMealData.analysis?.scientificInsights ? 
        JSON.stringify(normalizedMealData.scientificInsights || normalizedMealData.analysis?.scientificInsights) : null,
        
      goal_alignment: normalizedMealData.goalAlignment || normalizedMealData.analysis?.goalAlignment || '',
      glycemic_impact: normalizedMealData.glycemicImpact || normalizedMealData.analysis?.glycemicImpact || '',
      inflammatory_potential: normalizedMealData.inflammatoryPotential || normalizedMealData.analysis?.inflammatoryPotential || '',
      nutrient_density: normalizedMealData.nutrientDensity || normalizedMealData.analysis?.nutrientDensity || '',
      
      // Store the full analysis as JSON for reference
      analysis: JSON.stringify(normalizedMealData.analysis || {})
    };
    
    console.log('[API] Attempting to save meal to database with ID:', mealId);
    
    // Try using upsert instead of insert for better compatibility
    const { error: mealsError } = await supabase
      .from('meals')
      .upsert(dbEntry, { onConflict: 'id' });
  
    if (mealsError) {
      console.error('[DB] Error saving to meals table:', mealsError);
      
      // If the error is specific to updated_at column, try again without it
      if (mealsError.message && mealsError.message.includes('updated_at')) {
        console.log('[DB] Attempting to save without updated_at field');
        const { updated_at, ...entrySansUpdatedAt } = dbEntry;
        
        const { error: retryError } = await supabase
          .from('meals')
          .upsert(entrySansUpdatedAt, { onConflict: 'id' });
          
        if (retryError) {
          console.error('[DB] Second attempt failed:', retryError);
          
          // Fall back to direct insert
          console.log('[DB] Trying direct insert as last resort');
          const { error: insertError } = await supabase
            .from('meals')
            .insert(entrySansUpdatedAt);
            
          if (insertError) {
            console.error('[DB] All attempts to save to main table failed, using fallback');
            
            // Last resort: Try to save to meal_analyses table
            try {
              const { error: fallbackError } = await supabase
                .from('meal_analyses')
                .upsert(dbEntry);
              
              if (fallbackError) {
                console.error('[DB] Fallback save also failed:', fallbackError);
                return { success: false, mealId: mealId, error: fallbackError };
              } else {
                console.log('[DB] Successfully saved to meal_analyses table (fallback)');
                return { success: true, mealId: mealId };
      }
    } catch (e) {
              console.error('[DB] Exception during fallback save:', e);
              return { success: false, mealId: mealId, error: e };
            }
      } else {
            console.log('[DB] Direct insert succeeded');
            return { success: true, mealId: mealId };
          }
        } else {
          console.log('[DB] Second attempt succeeded (without updated_at)');
          return { success: true, mealId: mealId };
        }
      } else {
        // Try fallback table
        console.log('[DB] Trying fallback table');
        const { error: fallbackError } = await supabase
          .from('meal_analyses')
          .upsert(dbEntry);
        
        if (fallbackError) {
          console.error('[DB] Fallback save failed:', fallbackError);
          return { success: false, mealId: mealId, error: fallbackError };
        } else {
          console.log('[DB] Successfully saved to meal_analyses table (fallback)');
          return { success: true, mealId: mealId };
        }
      }
        } else {
      console.log('[DB] Successfully saved to meals table');
      return { success: true, mealId: mealId };
    }
  } catch (error) {
    console.error('[DB] Exception in saveMealToDatabase:', error);
    return { success: false, mealId: null, error };
  }
}

// Helper function to ensure proper JSON structure for JSONB fields
function ensureJsonStructure(data: any): any {
  if (!data) return [];
  
  // If it's a string, try to parse it
  if (typeof data === 'string') {
    try {
      return JSON.parse(data);
    } catch (e) {
      // If not valid JSON, wrap it in an array
      return [data];
    }
  }
  
  // If it's already an array, return it
  if (Array.isArray(data)) {
    return data;
  }
  
  // If it's an object, wrap it in an array
  if (typeof data === 'object') {
    return [data];
  }
  
  // Default: wrap in array
  return [data];
}

// Generate insights from analysis data
// Now this function is used internally only, not exported
function generateInsights(mealData: any, userProfile?: any): string {
  try {
    // Initialize the insights array
    const insights: string[] = [];
    
    // Add header and personalized greeting
    insights.push(`# ${mealData.mealName || 'Your Meal'} Analysis`);
    
    if (userProfile?.full_name) {
      insights.push(`Hello ${userProfile.full_name}, here's your personalized nutrition breakdown:`);
    } else {
      insights.push(`Here's your personalized nutrition breakdown:`);
    }
    
    // Add personalized insights if already available
    if (mealData.analysis?.personalized_insights) {
      insights.push(mealData.analysis.personalized_insights);
    }
    
    if (mealData.personalized_insights) {
      insights.push(mealData.personalized_insights);
    }
    
    // Generate insights array
    const goal = userProfile?.goal || userProfile?.healthGoals || mealData.goal || 'General Health';
    
    // Add personalized greeting if we have user data
    if (userProfile) {
      insights.push(`## Personalized Nutrition Analysis for Your ${goal} Goals`);
      if (userProfile.age) {
        insights.push(`As a ${userProfile.age}-year-old ${userProfile.gender || 'person'} focused on ${goal.toLowerCase()}, here's my comprehensive analysis of this meal:`);
      } else {
        insights.push(`Based on your ${goal.toLowerCase()} goals, here's my detailed analysis of this meal:`);
      }
    } else {
      insights.push(`## Nutritional Analysis`);
      insights.push(`Here's a detailed analysis of this meal for your ${goal} goals:`);
    }
    
    // Get the calories
    const calories = mealData.analysis?.calories || mealData.calories || 0;
    
    // Get macronutrients
    const macros = (mealData.analysis?.macronutrients || mealData.macronutrients || []);
    const protein = macros.find((m: any) => m.name?.toLowerCase().includes('protein'));
    const carbs = macros.find((m: any) => m.name?.toLowerCase().includes('carb'));
    const fat = macros.find((m: any) => m.name?.toLowerCase().includes('fat'));
    const fiber = macros.find((m: any) => m.name?.toLowerCase().includes('fiber'));
    
    // Add calorie assessment
    if (calories > 0) {
      let calorieAssessment = '';
      if (userProfile?.calorieTarget) {
        const caloriePercent = Math.round((calories / userProfile.calorieTarget) * 100);
        calorieAssessment = `This meal provides approximately **${caloriePercent}%** of your daily calorie target.`;
      } else if (goal.toLowerCase().includes('weight loss')) {
        calorieAssessment = calories < 500 ? 'This is a **low-calorie meal** suitable for weight loss goals.' :
                           calories < 700 ? 'This is a **moderate-calorie meal** that can fit into a weight loss plan with proper portion control.' :
                           'This is a **higher-calorie meal**. Consider adjusting portions or balancing with lighter meals throughout the day to align with your weight loss goals.';
      } else if (goal.toLowerCase().includes('muscle') || goal.toLowerCase().includes('strength')) {
        calorieAssessment = calories < 500 ? 'This meal is **relatively low in calories** for muscle-building goals. Consider adding more nutrient-dense foods to support tissue growth and recovery.' :
                           calories < 800 ? 'This meal provides a **moderate amount of calories** to support your muscle-building goals.' :
                           'This **calorie-dense meal** can help support your muscle-building and strength goals.';
      }
      
      insights.push(`### Caloric Content: ${calories} kcal`);
      insights.push(calorieAssessment);
    }
    
    // Add macronutrient assessment
    insights.push(`### Macronutrient Profile`);
    
    if (protein && protein.amount) {
      let proteinAssessment = '';
      if (goal.toLowerCase().includes('muscle') || goal.toLowerCase().includes('strength')) {
        proteinAssessment = protein.amount < 20 ? 'This meal is **relatively low in protein** for muscle-building goals. Consider adding more protein-rich foods.' :
                           protein.amount < 30 ? 'This meal provides a **moderate amount of protein** to support muscle maintenance.' :
                           'This meal is **high in protein**, which is excellent for muscle recovery and growth.';
    } else {
        proteinAssessment = protein.amount < 15 ? 'This meal contains a **modest amount of protein**.' :
                           protein.amount < 25 ? 'This meal provides a **good amount of protein** for general health maintenance.' :
                           'This meal is **high in protein**, supporting satiety and muscle maintenance.';
      }
      insights.push(`- **Protein:** ${protein.amount}${protein.unit} (${protein.percentDailyValue || '?'}% DV) - ${proteinAssessment}`);
    }
    
    if (carbs && carbs.amount) {
      let carbAssessment = '';
      if (goal.toLowerCase().includes('keto') || goal.toLowerCase().includes('low carb')) {
        carbAssessment = carbs.amount < 20 ? 'This meal is **low in carbohydrates**, aligning well with your low-carb/keto goals.' :
                        carbs.amount < 50 ? 'This meal contains a **moderate amount of carbohydrates**. Be mindful of your daily carb limit for your low-carb goals.' :
                        'This meal is **high in carbohydrates** which may exceed your targets for a low-carb/keto approach.';
      } else if (goal.toLowerCase().includes('athletic') || goal.toLowerCase().includes('performance')) {
        carbAssessment = carbs.amount < 30 ? 'This meal is **relatively low in carbohydrates** for optimal athletic performance. Consider adding more complex carbs if consuming before exercise.' :
                        carbs.amount < 60 ? 'This meal provides a **moderate amount of carbohydrates** to support athletic activity.' :
                        'This meal is **rich in carbohydrates**, providing good energy for athletic performance and recovery.';
        } else {
        carbAssessment = 'These carbohydrates provide energy for your daily activities.';
      }
      insights.push(`- **Carbohydrates:** ${carbs.amount}${carbs.unit} (${carbs.percentDailyValue || '?'}% DV) - ${carbAssessment}`);
    }
    
    if (fat && fat.amount) {
      let fatAssessment = '';
      if (goal.toLowerCase().includes('heart health')) {
        fatAssessment = 'Focus on the quality of fats - prioritize sources of unsaturated fats like those in olive oil, avocados, and fatty fish.';
      } else if (goal.toLowerCase().includes('keto')) {
        fatAssessment = fat.amount < 30 ? 'This meal is **relatively low in fats** for a ketogenic approach. Consider adding healthy fat sources.' :
                       fat.amount < 50 ? 'This meal provides a **moderate amount of fats** to support your ketogenic goals.' :
                       'This meal is **high in fats**, well-suited for a ketogenic approach.';
      } else {
        fatAssessment = 'These fats contribute to satiety and support nutrient absorption.';
      }
      insights.push(`- **Fats:** ${fat.amount}${fat.unit} (${fat.percentDailyValue || '?'}% DV) - ${fatAssessment}`);
    }
    
    if (fiber && fiber.amount) {
      insights.push(`- **Fiber:** ${fiber.amount}${fiber.unit} (${fiber.percentDailyValue || '?'}% DV) - Supports digestive health and provides sustained energy.`);
    }
    
    // Add micronutrient highlights
    const micros = (mealData.analysis?.micronutrients || mealData.micronutrients || []);
    if (micros.length > 0) {
      insights.push(`### Key Micronutrients`);
      
      // Find standout micronutrients (high % DV)
      const standoutMicros = micros
        .filter((m: any) => m.percentDailyValue && m.percentDailyValue > 25)
        .sort((a: any, b: any) => (b.percentDailyValue || 0) - (a.percentDailyValue || 0))
        .slice(0, 3);
      
      if (standoutMicros.length > 0) {
        standoutMicros.forEach((micro: any) => {
          insights.push(`- **${micro.name}:** ${micro.amount}${micro.unit} (${micro.percentDailyValue}% DV) - ${micro.description || getMicronutrientBenefit(micro.name)}`);
        });
      } else {
        // If no standout micros, just list a few
        micros.slice(0, 3).forEach((micro: any) => {
          insights.push(`- **${micro.name}:** ${micro.amount}${micro.unit} ${micro.percentDailyValue ? `(${micro.percentDailyValue}% DV)` : ''} - ${micro.description || getMicronutrientBenefit(micro.name)}`);
        });
      }
    }
    
    // Add phytonutrients if available
    const phytos = (mealData.analysis?.phytonutrients || mealData.phytonutrients || []);
    if (phytos.length > 0) {
      insights.push(`### Phytonutrients`);
      phytos.slice(0, 3).forEach((phyto: any) => {
        insights.push(`- **${phyto.name}:** ${phyto.significance || 'Provides antioxidant benefits'} - Found in ${phyto.food_source || 'this meal'}.`);
      });
    }
    
    // Add glycemic impact if available
    if (mealData.analysis?.glycemicImpact || mealData.glycemicImpact) {
      insights.push(`### Glycemic Impact`);
      insights.push(mealData.analysis?.glycemicImpact || mealData.glycemicImpact);
    }
    
    // Add inflammatory potential if available
    if (mealData.analysis?.inflammatoryPotential || mealData.inflammatoryPotential) {
      insights.push(`### Inflammatory Potential`);
      insights.push(mealData.analysis?.inflammatoryPotential || mealData.inflammatoryPotential);
    }
    
    // Add goal alignment
    if (mealData.analysis?.goalAlignment || mealData.goalAlignment) {
      insights.push(`### Goal Alignment`);
      insights.push(mealData.analysis?.goalAlignment || mealData.goalAlignment);
    } else {
      insights.push(`### Goal Alignment`);
      
      if (goal.toLowerCase().includes('weight loss')) {
        if (calories < 500) {
          insights.push(`This meal aligns well with your weight loss goals, providing good nutrition while being calorie-controlled.`);
        } else if (calories < 700) {
          insights.push(`This meal can fit into your weight loss plan, though portion control will be important to maintain a calorie deficit throughout the day.`);
        } else {
          insights.push(`This meal is relatively high in calories for a weight loss plan. Consider adjusting portions or balancing with lighter meals to maintain your calorie goals.`);
        }
      } else if (goal.toLowerCase().includes('muscle')) {
        const hasAdequateProtein = protein && protein.amount >= 20;
        const hasAdequateCalories = calories >= 500;
        
        if (hasAdequateProtein && hasAdequateCalories) {
          insights.push(`This meal supports your muscle-building goals well, providing adequate protein and calories to support recovery and growth.`);
        } else if (hasAdequateProtein) {
          insights.push(`This meal provides good protein for muscle building, but you may need more total calories to support optimal growth.`);
        } else if (hasAdequateCalories) {
          insights.push(`This meal provides good energy for muscle building, but adding more protein would better support muscle synthesis and recovery.`);
        } else {
          insights.push(`To better support your muscle-building goals, consider increasing both protein and overall calories in this meal.`);
        }
      } else {
        insights.push(`This meal provides a balance of nutrients that generally support your health and wellness goals.`);
      }
    }
    
    // Add Benefits and Concerns sections
    const benefits = mealData.benefits || mealData.analysis?.benefits || [];
    if (benefits.length > 0) {
      insights.push(`### Key Benefits`);
      benefits.forEach((benefit: string) => {
        insights.push(`- ${benefit}`);
      });
    }
    
    const concerns = mealData.concerns || mealData.analysis?.concerns || [];
    if (concerns.length > 0) {
      insights.push(`### Considerations`);
      concerns.forEach((concern: string) => {
        insights.push(`- ${concern}`);
      });
    }
    
    // Add recommendations section
    const suggestions = mealData.suggestions || mealData.analysis?.suggestions || [];
    if (suggestions.length > 0) {
      insights.push(`### Recommendations`);
      suggestions.forEach((suggestion: string) => {
        insights.push(`- ${suggestion}`);
      });
    } else {
      insights.push(`### Recommendations`);
      if (goal.toLowerCase().includes('weight loss')) {
        insights.push(`- Consider adding more vegetables to increase volume and fiber while keeping calories moderate.`);
        insights.push(`- Ensure adequate protein to maintain satiety and preserve lean muscle mass.`);
      } else if (goal.toLowerCase().includes('muscle')) {
        insights.push(`- Pair with adequate hydration to support recovery and nutrient transport.`);
        insights.push(`- Consider timing this meal within 1-2 hours after a workout for optimal recovery.`);
      } else {
        insights.push(`- Add a variety of colorful vegetables to increase phytonutrient content.`);
        insights.push(`- Balance your plate with appropriate portions of protein, complex carbs, and healthy fats.`);
      }
    }
    
    // Final personalized tip
    if (userProfile) {
      insights.push(`\n### Personalized Tip`);
      if (goal.toLowerCase().includes('weight loss')) {
        insights.push(`Maintaining a consistent eating schedule and practicing mindful eating can enhance your weight loss journey beyond just focusing on calories.`);
      } else if (goal.toLowerCase().includes('muscle')) {
        insights.push(`Remember that consistency in both nutrition and training is key for muscle development. This meal contributes to your overall nutritional strategy.`);
      } else if (goal.toLowerCase().includes('heart')) {
        insights.push(`Combining this nutrition approach with regular physical activity and stress management will provide the most comprehensive support for your cardiovascular health.`);
      } else {
        insights.push(`Consistent nutrition habits that include a variety of nutrient-dense foods like those in this meal form the foundation of long-term health and wellbeing.`);
      }
    }
    
    // Return the formatted insights
    return insights.join('\n\n');
  } catch (error) {
    console.error('Error generating insights:', error);
    return 'Unable to generate detailed insights for this meal.';
  }
}

// Add this helper function for safely updating progress
const updateProgress = (message: string | null) => {
  // This is a server-side function, so we can't directly update client state
  // We'll just log the progress for debugging
  console.log(`[API] Progress: ${message}`);
};

// Normalize meal data before saving to database
function normalizeMealData(mealData: any): any {
  // Create a deep copy to avoid modifying the original
  const normalized = JSON.parse(JSON.stringify(mealData));
  
  // Ensure basic fields
  normalized.caption = normalized.caption || normalized.mealName || normalized.name || 'Analyzed Meal';
  normalized.name = normalized.name || normalized.mealName || normalized.caption || 'Analyzed Meal';
  normalized.calories = normalized.calories || (normalized.analysis?.calories) || 0;
  
  // Extract nutrients from analysis if needed
  if (normalized.analysis) {
    // Handle macronutrients
    if (!normalized.macronutrients && normalized.analysis.macronutrients) {
      normalized.macronutrients = Array.isArray(normalized.analysis.macronutrients) 
        ? normalized.analysis.macronutrients : [];
    }
    
    // Handle micronutrients
    if (!normalized.micronutrients && normalized.analysis.micronutrients) {
      normalized.micronutrients = Array.isArray(normalized.analysis.micronutrients) 
        ? normalized.analysis.micronutrients : [];
    }
    
    // Handle benefits, concerns, suggestions
    if (!normalized.benefits && normalized.analysis.benefits) {
      normalized.benefits = Array.isArray(normalized.analysis.benefits) 
        ? normalized.analysis.benefits : [];
    }
    if (!normalized.concerns && normalized.analysis.concerns) {
      normalized.concerns = Array.isArray(normalized.analysis.concerns) 
        ? normalized.analysis.concerns : [];
    }
    if (!normalized.suggestions && normalized.analysis.suggestions) {
      normalized.suggestions = Array.isArray(normalized.analysis.suggestions) 
        ? normalized.analysis.suggestions : [];
    }
  }

  // Ensure all arrays are properly structured
  normalized.macronutrients = Array.isArray(normalized.macronutrients) ? normalized.macronutrients : [];
  normalized.micronutrients = Array.isArray(normalized.micronutrients) ? normalized.micronutrients : [];
  normalized.benefits = Array.isArray(normalized.benefits) ? normalized.benefits : [];
  normalized.concerns = Array.isArray(normalized.concerns) ? normalized.concerns : [];
  normalized.suggestions = Array.isArray(normalized.suggestions) ? normalized.suggestions : [];
  
  return normalized;
}

// Function to save meal data to database with better error handling
async function saveMealToDatabase(supabase: any, mealData: any, userId: string): Promise<{ success: boolean, mealId: string, error?: any }> {
  try {
    updateProgress("Saving meal data to database...");
    
    if (!mealData) {
      return { success: false, mealId: '', error: 'No meal data provided' };
    }
    
    // Generate a meal ID if not provided
    const mealId = mealData.id || crypto.randomUUID();
    
    // Ensure basic fields are present
    mealData.caption = mealData.caption || mealData.mealName || mealData.name || 'Analyzed Meal';
    mealData.name = mealData.name || mealData.mealName || mealData.caption || 'Analyzed Meal';
    mealData.calories = mealData.calories || (mealData.analysis?.calories) || 0;
    
    // Extract nutrients from analysis if needed
    if (mealData.analysis) {
      if (!mealData.macronutrients && mealData.analysis.macronutrients) {
        mealData.macronutrients = mealData.analysis.macronutrients;
      }
      if (!mealData.micronutrients && mealData.analysis.micronutrients) {
        mealData.micronutrients = mealData.analysis.micronutrients;
      }
      if (!mealData.benefits && mealData.analysis.benefits) {
        mealData.benefits = mealData.analysis.benefits;
      }
      if (!mealData.concerns && mealData.analysis.concerns) {
        mealData.concerns = mealData.analysis.concerns;
      }
      if (!mealData.suggestions && mealData.analysis.suggestions) {
        mealData.suggestions = mealData.analysis.suggestions;
      }
    }
    
    // Prepare the insert payload
    const payload = {
      id: mealId,
      user_id: userId || 'anonymous',
      caption: mealData.caption,
      name: mealData.name,
      image_url: mealData.imageUrl || mealData.image_url || '',
      calories: mealData.calories || 0,
      macronutrients: mealData.macronutrients || [],
      micronutrients: mealData.micronutrients || [],
      benefits: mealData.benefits || [],
      concerns: mealData.concerns || [],
      suggestions: mealData.suggestions || [],
      analysis: mealData.analysis || {},
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
    
    console.log(`[API] Saving meal data with ID: ${mealId}`);
    
    // Try inserting into the database
    const { error } = await supabase
      .from('meals')
      .upsert(payload);
      
    if (error) {
      console.error(`[API] Error saving to database:`, error);
      
      // Try a fallback method - using meal_analyses table
      const { error: fallbackError } = await supabase
        .from('meal_analyses')
        .upsert({
          id: mealId,
          user_id: userId || 'anonymous',
          name: mealData.caption || mealData.name,
          image_url: mealData.imageUrl || mealData.image_url || '',
          calories: mealData.calories || 0,
          data: mealData,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });
        
      if (fallbackError) {
        console.error(`[API] Fallback save also failed:`, fallbackError);
        return { success: false, mealId, error: fallbackError };
      }
    }
    
    updateProgress("Meal data saved successfully!");
    return { success: true, mealId };
  } catch (error) {
    console.error('[API] Unexpected error saving meal data:', error);
    return { success: false, mealId: '', error };
  }
}

// In the POST function, implement the complete flow
export async function POST(request: NextRequest): Promise<Response> {
  console.log('API route called: /api/analyze-meal');
  
  try {
    // Check if the OpenAI API key is present
    const openaiApiKey = process.env.OPENAI_API_KEY;
    console.log('OpenAI API Key present:', !!openaiApiKey);
    
    if (!openaiApiKey) {
      return NextResponse.json(
        { error: 'OpenAI API key is not configured' },
        { status: 500 }
      );
    }
    
    // Update progress safely instead of using setUploadProgress
    updateProgress('Processing uploaded image...');
    
    // Use FormData to get the uploaded file
    const formData = await request.formData();
    const file = formData.get('file') as File | null;
    const mealId = formData.get('mealId') as string || randomUUID();
    const goal = formData.get('goal') as string || 'General Wellness';
    
    if (!file) {
      console.error('[API] No image found in request');
      updateProgress('Error: No image provided');
      return new Response(JSON.stringify({
        error: 'No image provided',
        success: false
      }), { 
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    
    // Update progress with our safe function
    updateProgress('Reading image data...');
    
    // Get image type and data
    const contentType = file.type;
    const imageBuffer = Buffer.from(await file.arrayBuffer());
    
    // Get URL for uploads or use a placeholder
    let imageUrl = null;
    
    // Get the authentication token from the request
    const authHeader = request.headers.get('authorization');
    const middlewareAuthHeader = request.headers.get('x-auth-user-id');
    let userId: string | null = null;
    
    // Check for authenticated user in different ways
    if (middlewareAuthHeader) {
      // Get user ID from middleware headers (most reliable)
      userId = middlewareAuthHeader;
      console.log('[API] Authenticated user:', userId, '(source: middleware headers)');
    } else if (authHeader && authHeader.startsWith('Bearer ')) {
      // Get user ID from authorization header
      const token = authHeader.substring(7);
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      );
      
      const { data } = await supabase.auth.getUser(token);
      userId = data?.user?.id || null;
      console.log('[API] Authenticated user:', userId, '(source: auth header)');
    } else {
      console.log('[API] No authenticated user found, using anonymous mode');
    }
    
    // Create Supabase client
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);
    
    // Update progress with our safe function
    updateProgress('Uploading to storage...');
    
    // Use a safe file name
    const fileName = `meal-${mealId}`;
    
    // Upload to Supabase storage
    imageUrl = await uploadImageToSupabase(
      imageBuffer,
      fileName,
      contentType,
      userId || 'anonymous', 
      supabase
    );
    
    if (!imageUrl) {
      throw new Error('Failed to upload image to storage');
    }
    
    // Update progress with our safe function
    updateProgress('Image uploaded successfully');
    updateProgress('Generating analysis...');
    
    // Get user profile if available
    let userProfile = null;
    if (userId) {
      try {
        userProfile = await getUserProfile(userId);
      } catch (profileError) {
        console.error('[API] Error fetching user profile:', profileError);
        // Continue without profile
      }
    }
    
    // Now perform the analysis with the uploaded image URL
    updateProgress('Beginning analysis...');
    
    // Try-catch block to handle any errors in the analyze function
    let analysisResult;
    try {
      // Option 1: Use OpenAI analysis in a production app
      analysisResult = await analyzeMealImage(imageUrl, goal);
      
      // Generate insights with user profile when available
      if (userProfile && analysisResult) {
        // Add insights to the analysis
        const generatedInsights = generateMealInsights(analysisResult, userProfile);
        analysisResult.personalized_insights = generatedInsights;
      }
    } catch (analysisError) {
      console.error('[API] Error analyzing meal image:', analysisError);
      updateProgress('Error analyzing image');
      
      // Fall back to mock data
      console.log('[FALLBACK] Personalizing meal data based on user profile:', {
        goal,
        age: userProfile?.age,
        sex: userProfile?.gender,
        weight: userProfile?.weight
      });
      
      analysisResult = getCustomizedFallbackMeal(goal, imageUrl, userProfile);
    }
    
    // Add the meal ID to the result
    analysisResult.id = mealId;
    
    // Create the meal data object with analyzed information
    const mealData = {
      mealId: mealId,
      mealName: analysisResult.mealName || 'Analyzed Meal',
      goal: goal,
      analysis: analysisResult.analysis,
      detectedFood: analysisResult.detectedFood || analysisResult.foodName || ''
    };
    
    // Save to database using our helper function
    const dbSaveResult = await saveMealToDatabase(supabase, userId || 'anonymous', mealData, imageUrl);
    
    // Add database save result to the analysis response
    analysisResult.dbSaved = dbSaveResult.success;
    analysisResult.dbError = dbSaveResult.error;
    
    updateProgress('Analysis complete');
    
    // Return the result
    return new Response(JSON.stringify(analysisResult), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error: any) {
    console.error('[API] Unhandled error in analyze-meal API:', error);
    return new Response(JSON.stringify({ 
      success: false, 
      error: error.message || "Unknown error"
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// Helper function for micronutrient benefits
function getMicronutrientBenefit(nutrientName: string): string {
  const name = nutrientName.toLowerCase();
  
  if (name.includes('vitamin c')) return 'immune function and collagen production';
  if (name.includes('vitamin d')) return 'bone health and immune function';
  if (name.includes('vitamin b12')) return 'nerve function and red blood cell formation';
  if (name.includes('iron')) return 'oxygen transport and energy production';
  if (name.includes('calcium')) return 'bone health and muscle function';
  if (name.includes('potassium')) return 'heart health and muscle function';
  if (name.includes('magnesium')) return 'muscle recovery and nervous system function';
  
  return 'overall health';
}

// Normalize meal data before saving to database - renamed to avoid conflict
function normalizeAnalysisData(mealData: any): any {
  // Create a deep copy to avoid modifying the original
  const normalized = JSON.parse(JSON.stringify(mealData));
  
  // Ensure basic fields
  normalized.caption = normalized.caption || normalized.mealName || normalized.name || 'Analyzed Meal';
  normalized.name = normalized.name || normalized.mealName || normalized.caption || 'Analyzed Meal';
  normalized.calories = normalized.calories || (normalized.analysis?.calories) || 0;
  
  // Extract nutrients from analysis if needed
  if (normalized.analysis) {
    // Handle macronutrients
    if (!normalized.macronutrients && normalized.analysis.macronutrients) {
      normalized.macronutrients = Array.isArray(normalized.analysis.macronutrients) 
        ? normalized.analysis.macronutrients : [];
    }
    
    // Handle micronutrients
    if (!normalized.micronutrients && normalized.analysis.micronutrients) {
      normalized.micronutrients = Array.isArray(normalized.analysis.micronutrients) 
        ? normalized.analysis.micronutrients : [];
    }
    
    // Handle benefits, concerns, suggestions
    if (!normalized.benefits && normalized.analysis.benefits) {
      normalized.benefits = Array.isArray(normalized.analysis.benefits) 
        ? normalized.analysis.benefits : [];
    }
    if (!normalized.concerns && normalized.analysis.concerns) {
      normalized.concerns = Array.isArray(normalized.analysis.concerns) 
        ? normalized.analysis.concerns : [];
    }
    if (!normalized.suggestions && normalized.analysis.suggestions) {
      normalized.suggestions = Array.isArray(normalized.analysis.suggestions) 
        ? normalized.analysis.suggestions : [];
    }
  }

  // Ensure all arrays are properly structured
  normalized.macronutrients = Array.isArray(normalized.macronutrients) ? normalized.macronutrients : [];
  normalized.micronutrients = Array.isArray(normalized.micronutrients) ? normalized.micronutrients : [];
  normalized.benefits = Array.isArray(normalized.benefits) ? normalized.benefits : [];
  normalized.concerns = Array.isArray(normalized.concerns) ? normalized.concerns : [];
  normalized.suggestions = Array.isArray(normalized.suggestions) ? normalized.suggestions : [];
  
  return normalized;
}

// Function to save meal data to database with better error handling - renamed to avoid conflict
async function saveAnalysisToDatabase(supabase: any, mealData: any, userId: string): Promise<{ success: boolean, mealId: string, error?: any }> {
  try {
    updateProgress("Saving meal data to database...");
    
    if (!mealData) {
      return { success: false, mealId: '', error: 'No meal data provided' };
    }
    
    // Generate a meal ID if not provided
    const mealId = mealData.id || crypto.randomUUID();
    
    // Ensure basic fields are present
    mealData.caption = mealData.caption || mealData.mealName || mealData.name || 'Analyzed Meal';
    mealData.name = mealData.name || mealData.mealName || mealData.caption || 'Analyzed Meal';
    mealData.calories = mealData.calories || (mealData.analysis?.calories) || 0;
    
    // Extract nutrients from analysis if needed
    if (mealData.analysis) {
      if (!mealData.macronutrients && mealData.analysis.macronutrients) {
        mealData.macronutrients = mealData.analysis.macronutrients;
      }
      if (!mealData.micronutrients && mealData.analysis.micronutrients) {
        mealData.micronutrients = mealData.analysis.micronutrients;
      }
      if (!mealData.benefits && mealData.analysis.benefits) {
        mealData.benefits = mealData.analysis.benefits;
      }
      if (!mealData.concerns && mealData.analysis.concerns) {
        mealData.concerns = mealData.analysis.concerns;
      }
      if (!mealData.suggestions && mealData.analysis.suggestions) {
        mealData.suggestions = mealData.analysis.suggestions;
      }
    }
    
    // Prepare the insert payload
    const payload = {
      id: mealId,
      user_id: userId || 'anonymous',
      caption: mealData.caption,
      name: mealData.name,
      image_url: mealData.imageUrl || mealData.image_url || '',
      calories: mealData.calories || 0,
      macronutrients: mealData.macronutrients || [],
      micronutrients: mealData.micronutrients || [],
      benefits: mealData.benefits || [],
      concerns: mealData.concerns || [],
      suggestions: mealData.suggestions || [],
      analysis: mealData.analysis || {},
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
    
    console.log(`[API] Saving meal data with ID: ${mealId}`);
    
    // Try inserting into the database
    const { error } = await supabase
      .from('meals')
      .upsert(payload);
      
    if (error) {
      console.error(`[API] Error saving to database:`, error);
      
      // Try a fallback method - using meal_analyses table
      const { error: fallbackError } = await supabase
        .from('meal_analyses')
        .upsert({
          id: mealId,
          user_id: userId || 'anonymous',
          name: mealData.caption || mealData.name,
          image_url: mealData.imageUrl || mealData.image_url || '',
          calories: mealData.calories || 0,
          data: mealData,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });
        
      if (fallbackError) {
        console.error(`[API] Fallback save also failed:`, fallbackError);
        return { success: false, mealId, error: fallbackError };
      }
    }
    
    updateProgress("Meal data saved successfully!");
    return { success: true, mealId };
  } catch (error) {
    console.error('[API] Unexpected error saving meal data:', error);
    return { success: false, mealId: '', error };
  }
}
