import { mealJsonParse, createFallbackMealResponse } from './json-fix';
import { NextRequest, NextResponse } from 'next/server';
import { v4 as uuidv4, v5 as uuidv5, validate as validateUUID } from 'uuid';
import OpenAI from 'openai';
import { getUserIdFromSession } from '@/lib/auth';
import { 
  validateMealAnalysisData, 
  retryWithExponentialBackoff,
  createMealAnalysisSchema,
  formatMealForStorage 
} from '@/app/lib/api-utils';
import { 
  analyzeImageWithGPT,
  reanalyzeWithCorrections 
} from '@/app/lib/openai-utils';
import { anonClient, adminClient } from '@/utils/supabase';
import { safeStringify } from '@/utils/json-helpers';

// UUID namespace for consistent string-to-UUID conversion
const UUID_NAMESPACE = '1b671a64-40d5-491e-99b0-da01ff1f3341';

/**
 * Convert a string to a UUID in a deterministic way
 * This allows us to handle both UUID and string IDs consistently
 */
function stringToUUID(str: string): string {
  if (validateUUID(str)) {
    return str; // Already a valid UUID
  }
  // Generate a deterministic UUID from the string
  return uuidv5(str, UUID_NAMESPACE);
}

// Force this route to be dynamic
export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';
export const revalidate = 0;
export const fetchCache = 'only-no-store';

/**
 * GET handler to retrieve meal analysis by ID
 */
export async function GET(request: NextRequest) {
  console.log('[api/analyze-meal] GET request received');
  
  try {
    // Get meal ID from query parameter
    const { searchParams } = new URL(request.url);
    const mealId = searchParams.get('id');
    const statusOnly = searchParams.get('statusOnly') === 'true';
    
    console.log(`[api/analyze-meal] GET request for meal ID: ${mealId}, statusOnly: ${statusOnly}`);
    
    if (!mealId) {
      return NextResponse.json(
        { success: false, error: 'Missing meal ID parameter', data: null },
        { status: 400 }
      );
    }
    
    // Use the Supabase client from utils/supabase.ts
    const supabase = anonClient;
    
    let userId: string | null = null;
    
    // Try to get userId but don't fail if we can't
    try {
      const { userId: sessionUserId } = await getUserIdFromSession(request);
      userId = sessionUserId;
      console.log(`[api/analyze-meal] Authenticated user: ${userId}`);
    } catch (authError) {
      console.warn('[api/analyze-meal] Auth warning, continuing without userId:', authError);
      // Continue with null userId for public access
    }
    
    // Initialize retry counter and max attempts
    let attempts = 0;
    const maxAttempts = 3;
    
    while (attempts < maxAttempts) {
      attempts++;
      
      try {
        // Try meal_analyses table first (newest schema)
        console.log('[api/analyze-meal] Querying meal_analyses table with ID:', mealId);
        const { data: analysisData, error: analysisError } = await supabase
          .from('meal_analyses')
          .select('*')
          .eq('uuid', mealId)
          .maybeSingle();
          
        if (analysisError) {
          console.error('[api/analyze-meal] Error querying meal_analyses:', analysisError);
        }
          
        if (!analysisError && analysisData) {
          console.log('[api/analyze-meal] Found meal in meal_analyses table');
          
          // If status check only, return minimal data
          if (statusOnly) {
            return NextResponse.json({
              success: true,
              data: {
                status: 'complete',
                mealId: analysisData.uuid
              },
              error: null
            });
          }
          
          // Format response data
          const responseData = {
            success: true,
            data: {
              uuid: analysisData.uuid,
              mealId: analysisData.uuid,
              mealName: analysisData.name || 'Meal Analysis',
              imageUrl: analysisData.image_url,
              goal: analysisData.goal || 'General Health',
              calories: analysisData.calories || 0,
              macronutrients: analysisData.macronutrients || [],
              micronutrients: analysisData.micronutrients || [],
              insights: analysisData.insights || '',
              _source: 'meal_analyses'
            },
            error: null
          };
          
          return NextResponse.json(safeStringify(responseData));
        }
        
        // Try the meals table next
        console.log('[api/analyze-meal] Querying meals table with ID:', mealId);
        const { data: mealData, error: mealError } = await supabase
          .from('meals')
          .select('*')
          .eq('id', mealId)
          .maybeSingle();
        
        if (mealError) {
          console.error('[api/analyze-meal] Error querying meals table:', mealError);
        }
        
        if (!mealError && mealData) {
          console.log('[api/analyze-meal] Found meal in meals table');
          
          // If status check only, return minimal data
          if (statusOnly) {
            return NextResponse.json({
              success: true,
              data: {
                status: 'complete',
                mealId: mealData.id
              },
              error: null
            });
          }
          
          // Format response data
          const responseData = {
            success: true,
            data: {
              mealId: mealData.id,
              mealName: mealData.meal_name || 'Meal Analysis',
              imageUrl: mealData.image_url,
              goal: mealData.goal || 'General Health',
              calories: mealData.calories || 0,
              macronutrients: mealData.macronutrients || [],
              micronutrients: mealData.micronutrients || [],
              benefits: mealData.benefits || [],
              concerns: mealData.concerns || [],
              suggestions: mealData.suggestions || [],
              insights: (mealData.analysis && mealData.analysis.insights) || mealData.insights || null,
              _source: 'meals'
            },
            error: null
          };
          
          return NextResponse.json(safeStringify(responseData));
        }
        
        // Finally, try the backup table
        console.log('[api/analyze-meal] Querying meal_data_backup table with ID:', mealId);
        const { data: backupData, error: backupError } = await supabase
          .from('meal_data_backup')
          .select('*')
          .eq('id', mealId)
          .maybeSingle();
        
        if (backupError) {
          console.error('[api/analyze-meal] Error querying meal_data_backup table:', backupError);
        }
        
        if (!backupError && backupData) {
          console.log('[api/analyze-meal] Found meal in meal_data_backup table');
          
          // Parse the data JSON field if it exists
          let parsedData = backupData.data || {};
          if (typeof parsedData === 'string') {
            try {
              parsedData = mealJsonParse(parsedData, {});
            } catch (parseError) {
              console.error('[api/analyze-meal] Error parsing backup data JSON:', parseError);
            }
          }
          
          // If status check only, return minimal data
          if (statusOnly) {
            return NextResponse.json({
              success: true,
              data: {
                status: 'complete',
                mealId: backupData.id
              },
              error: null
            });
          }
          
          // Format response data
          const responseData = {
            success: true,
            data: {
              mealId: backupData.id,
              mealName: parsedData.mealName || backupData.name || 'Meal Analysis',
              imageUrl: parsedData.imageUrl || backupData.image_url,
              goal: parsedData.goal || 'General Health',
              calories: parsedData.calories || 0,
              macronutrients: parsedData.macronutrients || [],
              micronutrients: parsedData.micronutrients || [],
              insights: parsedData.insights || '',
              _source: 'meal_data_backup'
            },
            error: null
          };
          
          return NextResponse.json(safeStringify(responseData));
        }
        
        // If we've checked all tables and found nothing, respond with 404
        console.log('[api/analyze-meal] Meal not found in any table:', mealId);
        return NextResponse.json(
          { 
            success: false, 
            error: 'Meal not found',
            data: null
          },
          { status: 404 }
        );
      } catch (dbError) {
        console.error(`[api/analyze-meal] Database error (attempt ${attempts}/${maxAttempts}):`, dbError);
        
        if (attempts >= maxAttempts) {
          return NextResponse.json(
            { 
              success: false, 
              error: 'Database error', 
              details: dbError.message,
              data: null
            },
            { status: 500 }
          );
        }
        
        // Wait before retrying
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    // If we've exhausted all retry attempts, return a server error
    return NextResponse.json(
      { 
        success: false, 
        error: 'Server error after multiple attempts',
        data: null
      },
      { status: 500 }
    );
  } catch (error) {
    console.error('[api/analyze-meal] Unhandled error in GET handler:', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: 'An unexpected error occurred',
        details: error.message,
        data: null
      },
      { status: 500 }
    );
  }
}

/**
 * POST handler to analyze a meal from an image URL
 */
export async function POST(req: NextRequest) {
  console.log('[analyze-meal] Received request to analyze meal');
  
  try {
    let body: any = {};
    let imageUrl: string = '';
    let goal: string = 'General Health';
    
    // Check content type to determine how to parse the request
    const contentType = req.headers.get('content-type') || '';
    
    if (contentType.includes('multipart/form-data')) {
      // Handle multipart form data
      try {
        const formData = await req.formData();
        
        // Get image from form data - it could be a File object or a URL string
        const image = formData.get('image');
        
        if (image instanceof File) {
          // If it's a file, convert to data URL
          const buffer = await image.arrayBuffer();
          const base64 = Buffer.from(buffer).toString('base64');
          const mimeType = image.type;
          imageUrl = `data:${mimeType};base64,${base64}`;
        } else if (typeof image === 'string') {
          // If already a string (URL), use it directly
          imageUrl = image;
        }
        
        // Get other fields from form data
        goal = formData.get('goal')?.toString() || goal;
        
        // Get any additional data
        const entries = Array.from(formData.entries());
        for (const [key, value] of entries) {
          if (key !== 'image' && key !== 'goal') {
            body[key] = value;
          }
        }
      } catch (formError) {
        console.error('[analyze-meal] Error parsing form data:', formError);
        return NextResponse.json({
          success: false,
          error: 'Failed to parse form data'
        }, { status: 400 });
      }
    } else {
      // Handle JSON data
      try {
        const jsonText = await req.text();
        body = mealJsonParse(jsonText, {});
        
        if (!body) {
          return NextResponse.json({
            success: false,
            error: 'Invalid JSON in request body'
          }, { status: 400 });
        }
        
        imageUrl = body.imageUrl || '';
        goal = body.goal || goal;
      } catch (parseError) {
        console.error('[analyze-meal] Error parsing request body:', parseError);
        return NextResponse.json({
          success: false,
          error: 'Failed to parse request body'
        }, { status: 400 });
      }
    }
    
    if (!imageUrl) {
      return NextResponse.json({ 
        success: false, 
        error: 'Image is required' 
      }, { status: 400 });
    }
    
    // Validate the image URL
    try {
      // Check if it's a valid URL or data URL
      if (!imageUrl.startsWith('data:image/') && !imageUrl.startsWith('http')) {
        throw new Error('Invalid image URL format');
      }
      
      // If it's a standard URL (not data URL), validate it further
      if (imageUrl.startsWith('http')) {
        new URL(imageUrl);
      }
    } catch (urlError) {
      console.error('[analyze-meal] Invalid image URL:', urlError);
      return NextResponse.json({ 
        success: false, 
        error: 'Invalid image URL format' 
      }, { status: 400 });
    }
    
    // Use the Supabase client from utils/supabase.ts
    // Using adminClient for writes
    const writeClient = adminClient;
    
    // Get user ID from the request
    let userId: string = 'anonymous-user'; // Set a default
    
    try {
      const { userId: sessionUserId } = await getUserIdFromSession(req);
      if (sessionUserId) {
        userId = sessionUserId;
        console.log(`[analyze-meal] User ID: ${userId}`);
      }
    } catch (authError) {
      console.warn('[analyze-meal] Auth error, using anonymous mode:', authError);
      
      if (process.env.NODE_ENV === 'production') {
        return NextResponse.json({ 
          success: false, 
          error: 'Authentication required' 
        }, { status: 401 });
      }
    }
    
    let analysisResult;

    try {
      // Use OpenAI directly instead of the internal API to avoid URL resolution issues
      console.log('[analyze-meal] Analyzing image using OpenAI directly');
      
      // Use the analyzeImageWithGPT utility directly
      try {
        console.log('[analyze-meal] Calling OpenAI for analysis with goal:', goal);
        
        // Use the OpenAI utils directly
        const mealAnalysis = await analyzeImageWithGPT(
          imageUrl, // Pass the URL directly - the function will handle it
          goal,
          req.headers.get('x-mock-openai') === 'true' // Enable mock mode if header is present
        );
        
        // Format the response to match what would come from the analyze-image API
        analysisResult = {
          success: true,
          mealAnalysis
        };
        
        console.log('[analyze-meal] Analysis completed successfully');
      } catch (analysisError) {
        console.error('[analyze-meal] Direct OpenAI analysis failed:', analysisError);
        
        // Fall back to a simple analysis
        analysisResult = {
          success: true,
          mealAnalysis: {
            mealName: 'Food Analysis',
            calories: 0,
            macronutrients: [
              { name: "Protein", amount: 0, unit: "g", percentDailyValue: 0 },
              { name: "Carbs", amount: 0, unit: "g", percentDailyValue: 0 },
              { name: "Fat", amount: 0, unit: "g", percentDailyValue: 0 }
            ],
            micronutrients: [],
            insights: "We couldn't properly analyze this image. Please try again with a clearer picture of the food."
          }
        };
        
        console.log('[analyze-meal] Using fallback analysis due to OpenAI error');
      }
    } catch (error) {
      console.error('[analyze-meal] Error analyzing image:', error);
      return NextResponse.json({ 
        success: false, 
        error: `Error analyzing image: ${error.message}` 
      }, { status: 500 });
    }
    
    // Validate analysis result
    if (!analysisResult || !analysisResult.mealAnalysis) {
      console.error('[analyze-meal] Invalid analysis result format:', analysisResult);
      return NextResponse.json({ 
        success: false, 
        error: 'Invalid analysis result format' 
      }, { status: 500 });
    }
    
    // Generate a unique ID for this meal
    const mealId = uuidv4();
    
    // Format the meal data for the response
    const formattedMeal = formatMealForStorage(
      analysisResult.mealAnalysis, 
      { imageUrl, userId, mealId }
    );
    
    console.log(`[analyze-meal] Storing meal data with ID: ${mealId}`);
    
    // Create a database record
    const dbRecord = {
      id: mealId,
      user_id: userId,
      image_url: imageUrl,
      meal_name: formattedMeal.meal_name || "Unknown Meal",
      calories: formattedMeal.calories || 0,
      analysis: formattedMeal,
      macronutrients: formattedMeal.macronutrients || [],
      micronutrients: formattedMeal.micronutrients || [],
      goal: formattedMeal.goal || "General Health"
    };
    
    // Store the meal data in the database with retry logic
    let storageSuccess = false;
    let storageError: string | null = null;
    let attempts = 0;
    const maxAttempts = 3;
    
    while (!storageSuccess && attempts < maxAttempts) {
      attempts++;
      
      try {
        // Try a streamlined record first to avoid column errors
        const basicRecord = {
          id: mealId,
          user_id: userId,
          image_url: imageUrl,
          meal_name: formattedMeal.meal_name || "Unknown Meal",
          calories: formattedMeal.calories || 0,
          analysis: safeStringify(formattedMeal) // Store all data in the JSONB analysis field
        };
        
        // Use adminClient for database operations to bypass RLS if needed
        const { error } = await writeClient
          .from('meals')
          .insert([safeStringify(basicRecord)]);
        
        if (error) {
          console.error(`[analyze-meal] Error storing meal data (attempt ${attempts}/${maxAttempts}):`, error);
          storageError = error.message;
          
          // Check if it's a column missing error
          if (error.message?.includes("Could not find") && error.message?.includes("column")) {
            console.log('[analyze-meal] Detected column issue, trying with minimal record');
            
            // Try with only essential columns that should exist in all schemas
            const minimalRecord = {
              id: mealId,
              user_id: userId,
              image_url: imageUrl
            };
            
            const { error: minimalError } = await writeClient
              .from('meals')
              .insert([safeStringify(minimalRecord)]);
              
            if (minimalError) {
              console.error(`[analyze-meal] Error with minimal record (attempt ${attempts}/${maxAttempts}):`, minimalError);
              storageError = minimalError.message;
              
              // If the minimal record also fails, try meal_data_backup table as fallback
              if (attempts === maxAttempts) {
                console.log('[analyze-meal] Trying backup table as last resort');
                
                try {
                  // Store in backup table if it exists
                  const { error: backupError } = await writeClient
                    .from('meal_data_backup')
                    .insert([{
                      id: mealId,
                      user_id: userId,
                      image_url: imageUrl,
                      name: formattedMeal.meal_name || "Unknown Meal",
                      data: safeStringify(formattedMeal)
                    }]);
                    
                  if (!backupError) {
                    console.log('[analyze-meal] Successfully stored meal in backup table');
                    storageSuccess = true;
                    break;
                  } else {
                    console.error('[analyze-meal] Error with backup table:', backupError);
                  }
                } catch (backupException) {
                  console.error('[analyze-meal] Exception with backup table:', backupException);
                }
              }
            } else {
              console.log('[analyze-meal] Successfully stored meal with minimal schema');
              storageSuccess = true;
              break;
            }
          }
          
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, 1000));
        } else {
          console.log('[analyze-meal] Meal data stored successfully');
          storageSuccess = true;
        }
      } catch (error) {
        console.error(`[analyze-meal] Exception storing meal data (attempt ${attempts}/${maxAttempts}):`, error);
        storageError = error.message;
        
        if (attempts >= maxAttempts) {
          console.warn('[analyze-meal] Giving up after multiple storage attempts');
          // Try in-memory storage if available
          try {
            console.log('[analyze-meal] Attempting local storage fallback');
            
            // This would work with client-side code
            if (typeof window !== 'undefined' && window.localStorage) {
              const localStorageKey = `meal_${mealId}`;
              window.localStorage.setItem(localStorageKey, safeStringify(formattedMeal));
              console.log('[analyze-meal] Stored meal data in localStorage');
              storageSuccess = true;
              break;
            }
          } catch (localError) {
            console.error('[analyze-meal] localStorage fallback failed:', localError);
          }
          break;
        }
        
        // Wait before retrying
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    // Return a 202 Accepted response with the meal ID for polling
    const responseData = {
      success: true,
      data: {
        mealId,
        status: 'processing',
        imageUrl,
        goal,
        storedSuccessfully: storageSuccess
      }
    };
    
    // If storage failed, include the error
    if (!storageSuccess && storageError) {
      // Use type assertion to add the storageError property
      (responseData.data as any).storageError = storageError;
    }
    
    // Sanitize the response data to prevent JSON issues
    const safeResponseData = safeStringify(responseData);
    return NextResponse.json(safeResponseData, { status: 202 });
  } catch (error) {
    console.error('[analyze-meal] Unhandled error in route handler:', error);
    
    // Ensure the error message is safe to send
    const errorMessage = error?.message || 'An unexpected error occurred';
    const safeErrorResponse = safeStringify({ 
      success: false, 
      error: errorMessage
    });
    
    return NextResponse.json(safeErrorResponse, { status: 500 });
  }
}
