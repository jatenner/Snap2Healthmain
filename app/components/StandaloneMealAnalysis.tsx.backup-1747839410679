'use client';

import React, { useState, useEffect, useCallback, useRef } from 'react';
import Image from 'next/image';
import Link from 'next/link';
import { ChevronsLeft, Star, Share2, Download, HelpCircle, Info, User, Activity, UserCheck, History, Printer, CheckCircle, Upload, Camera, AlertCircle, Check, ArrowLeft } from 'lucide-react';
import LoadingSpinner from './LoadingSpinner';
import MealImage from './MealImage';
import { useAuth } from '../context/auth';
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
import EnhancedNutrientDisplay from './EnhancedNutrientDisplay';
import AIHealthReview from './AIHealthReview';
import { 
  UserProfile as ProfileUtilsUserProfile,
  ExtendedUserProfile, 
  getEffectiveProfile, 
  isProfileComplete, 
  calculatePersonalizedDV,
  NUTRIENT_DESCRIPTIONS, 
  getCompleteProfileButton 
} from '../lib/profile-utils';
import { useDropzone } from 'react-dropzone';
import { useProfile } from '../lib/profile-context';
import { v4 as uuidv4 } from 'uuid';

// Add TypeScript declarations for our custom window properties
declare global {
  interface Window {
    loadMealAnalysisData?: (mealId: string) => any;
    loadMealImageData?: (mealId: string) => { imageUrl?: string } | null;
    currentMealId?: string;
    forceRedirectToAnalysis?: (mealId: string) => void;
    profileDebug?: {
      checkLocalStorage: () => any;
      validateProfileData: (profile: any) => any;
      fixProfile: () => any;
      clearProfile: () => void;
    };
    _forcedProfileData?: any;
    fixOpenAIModel?: () => void;
    fixOpenAIApiKey?: () => void;
    __OPENAI_API_KEY_AVAILABLE?: boolean;
    __OPENAI_MODEL_NAME?: string;
  }
}

// Use a more flexible UserProfile type for compatibility
type UserProfile = any;

// Define the types for meal data
interface Nutrient {
      name: string;
      amount: number;
      unit: string;
  percentDailyValue: number;
      description?: string;
}

interface Ingredient {
      name: string;
  portion?: string;
  calories?: number;
}

interface Analysis {
  calories?: number;
  totalCalories?: number;
  macronutrients?: Nutrient[];
  micronutrients?: Nutrient[];
}

interface MealData {
  id: string;
  mealName: string;
  goal: string;
  imageUrl: string;
  mealContents?: any;
  mealDescription?: string;
  ingredients?: Ingredient[];
  analysis?: Analysis;
  benefits?: string[];
  concerns?: string[];
  suggestions?: string[];
  insights?: string;
  tags?: string[];
}

// MealContents interface to properly type the mealContents object
interface MealContents {
  foods?: Array<{ name: string; amount: string }>;
  [key: string]: any;
}

interface StandaloneMealAnalysisProps {
  initialMeal?: any;
  embedded?: boolean;
  mealId?: string | null;
}

// Define a helper function to replace getMissingProfileFields
const getMissingFields = (profile: any): string[] => {
  if (!profile) return ['complete profile'];
  
  const requiredFields = ['age', 'gender', 'weight', 'height', 'goal', 'activity_level'];
  return requiredFields.filter(field => !profile[field]);
};

// Standalone component that doesn't rely on context
export default function StandaloneMealAnalysis({ 
  initialMeal,
  embedded = false,
  mealId: propMealId = null
}: StandaloneMealAnalysisProps) {
  // Store the mealId in state immediately to ensure it's available for all hooks
  const [mealId, setMealId] = useState<string | null>(propMealId);
  
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [effectiveProfile, setEffectiveProfile] = useState<ExtendedUserProfile | null>(null);
  const [profileComplete, setProfileComplete] = useState(false);
  const [missingFields, setMissingFields] = useState<string[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [mealData, setMealData] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [analysisComplete, setAnalysisComplete] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [processingProgress, setProcessingProgress] = useState(0);
  const [processingMessage, setProcessingMessage] = useState('Processing your meal...');
  
  // Refs to track component state
  const initialized = useRef(false);
  const pollingInterval = useRef<NodeJS.Timeout | null>(null);
  const mealIdRef = useRef(mealId);

  // Update ref when mealId changes
  useEffect(() => {
    mealIdRef.current = mealId;
    
    // Also set on window for compatibility with other scripts
    if (typeof window !== 'undefined' && mealId) {
      window.currentMealId = mealId;
    }
  }, [mealId]);
  
  // State for saving meal to history
  const [isSaving, setIsSaving] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  const [saveSuccess, setSaveSuccess] = useState(false);
  const { user } = useAuth();
  const supabase = createClientComponentClient();
  
  // State for image upload and analysis
  const [file, setFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [mealName, setMealName] = useState('My Meal');
  const [mealGoal, setMealGoal] = useState('General Health');
  const [attemptCount, setAttemptCount] = useState(0);
  
  const { profile: profileFromContext } = useProfile();
  
  // Initialize and load data
  useEffect(() => {
    // Load meal data if ID is provided
    if (mealId) {
      console.log('[StandaloneMealAnalysis] Initial mealId available, fetching data:', mealId);
      fetchMealData();
    } else if (initialMeal) {
      // Use provided initial meal data if available
      console.log('[StandaloneMealAnalysis] Using provided initialMeal data');
      setMealData(initialMeal);
      setIsLoading(false);
    }
    
    // Clean up on unmount
    return () => {
      if (pollingInterval.current) {
        console.log('[StandaloneMealAnalysis] Cleaning up polling interval on unmount');
        clearInterval(pollingInterval.current);
        pollingInterval.current = null;
      }
    };
  }, [mealId, initialMeal]);
  
  // Initialize profile data
  useEffect(() => {
    // Get profile from context or localStorage
    const profile = profileFromContext || 
                   (typeof window !== 'undefined' && window._forcedProfileData) || 
                   null;
    
    if (profile) {
      setUserProfile(profile);
      
      // Get the enhanced profile with calculations
      const enhanced = getEffectiveProfile(profile);
      setEffectiveProfile(enhanced);
      
      // Update profile status
      setProfileComplete(isProfileComplete(profile));
      setMissingFields(getMissingFields(profile));
    }
    
    // Listen for profile updates
    const handleProfileUpdate = () => {
      const updatedProfile = profileFromContext || 
                           (typeof window !== 'undefined' && window._forcedProfileData) || 
                           null;
      if (updatedProfile) {
        setUserProfile(updatedProfile);
        setEffectiveProfile(getEffectiveProfile(updatedProfile));
        setProfileComplete(isProfileComplete(updatedProfile));
        setMissingFields(getMissingFields(updatedProfile));
      }
    };
    
    window.addEventListener('profile-updated', handleProfileUpdate);
    return () => window.removeEventListener('profile-updated', handleProfileUpdate);
  }, [profileFromContext]);
  
  // Process the file when selected
  const onDrop = useCallback((acceptedFiles: File[]) => {
    if (acceptedFiles.length > 0) {
      const selectedFile = acceptedFiles[0];
      
      if (selectedFile.type.startsWith('image/')) {
        setFile(selectedFile);
        setPreviewUrl(URL.createObjectURL(selectedFile));
        setError('');
      } else {
        setError('Please upload an image file (JPEG, PNG, etc.)');
      }
    }
  }, []);
  
  // Set up dropzone
  const { getRootProps, getInputProps, isDragActive } = useDropzone({ 
    onDrop,
    accept: {
      'image/*': ['.jpeg', '.jpg', '.png', '.heic', '.heif']
    },
    maxFiles: 1
  });
  
  // Submit the image for analysis
  const analyzeImage = async () => {
    if (!file) {
      setError('Please select an image to analyze');
      return;
    }
    
    try {
      setIsLoading(true);
      setError('');
      
      // Create form data to send
      const formData = new FormData();
      formData.append('file', file);
      formData.append('mealName', mealName);
      formData.append('goal', mealGoal);
      
      // Add user profile data if available
      if (effectiveProfile) {
        formData.append('userProfile', JSON.stringify(effectiveProfile));
      }
      
      // Send the image for analysis
      const response = await fetch('/api/analyze-meal', {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to analyze meal');
      }
      
      // Get the analysis result
      const result = await response.json();
      
      if (result.success) {
        // Save the data
        setMealData(result.mealData);
        setAnalysisComplete(true);
        
        // Redirect to the meal analysis page unless embedded
        if (!embedded && result.redirectUrl) {
          window.location.href = result.redirectUrl;
        }
      } else {
        throw new Error(result.error || 'Failed to analyze meal');
      }
    } catch (err) {
      console.error('Error analyzing meal:', err);
      setError(err instanceof Error ? err.message : 'An error occurred during analysis');
      setAttemptCount(prev => prev + 1);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Reset the form
  const resetForm = () => {
    setFile(null);
    setPreviewUrl(null);
    setMealName('My Meal');
    setMealGoal('General Health');
    setError('');
    setAnalysisComplete(false);
    setMealData(null);
  };
  
  // Save the analyzed meal to user history
  const saveMealToHistory = async () => {
    if (!mealData || !user) {
      setSaveError('Cannot save meal: Missing meal data or user not logged in');
      return;
    }
    
    try {
      setIsSaving(true);
      setSaveError(null);
      
      // Generate a UUID if one doesn't exist
      const mealId = mealData.id || uuidv4();
      
      // Prepare the meal data for the database with comprehensive structure
      const mealEntry = {
        id: mealId,
        user_id: user.id,
        name: mealData.mealName,
        caption: mealData.mealName,
        description: mealData.mealDescription || `Analysis of ${mealData.mealName}`,
        image_url: mealData.imageUrl,
        goal: mealData.goal || mealGoal,
        detected_food: mealData.mealContents?.foods?.map((f: any) => f.name).join(', ') || '',
        calories: mealData.analysis?.calories || 0,
        macronutrients: mealData.analysis?.macronutrients || [],
        micronutrients: mealData.analysis?.micronutrients || [],
        benefits: mealData.benefits || [],
        concerns: mealData.concerns || [],
        suggestions: mealData.suggestions || [],
        analysis: {
          ...mealData.analysis,
          userProfile: {
            goal: effectiveProfile?.goal,
            age: effectiveProfile?.age,
            gender: effectiveProfile?.gender,
            activity_level: effectiveProfile?.activity_level
          },
          insights: mealData.insights || '',
          timestamp: new Date().toISOString()
        },
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      
      console.log('[StandaloneMealAnalysis] Saving meal to Supabase:', mealId);
      
      // Insert into the meals table
      const { error } = await supabase
        .from('meals')
        .upsert(mealEntry);
      
      if (error) {
        console.error('[StandaloneMealAnalysis] Supabase error:', error);
        
        // Try fallback method using RPC if direct insert fails
        try {
          const { error: rpcError } = await supabase.rpc('admin_insert_meal', {
            p_id: mealId,
            p_user_id: user.id,
            p_meal_name: mealData.mealName,
            p_image_url: mealData.imageUrl,
            p_detected_food: mealEntry.detected_food,
            p_analysis: mealEntry.analysis,
            p_macronutrients: mealEntry.macronutrients,
            p_micronutrients: mealEntry.micronutrients,
            p_calories: mealEntry.calories,
            p_goal: mealEntry.goal,
            p_tags: mealData.tags || []
          });
          
          if (rpcError) {
            throw new Error(`RPC fallback failed: ${rpcError.message}`);
          } else {
            console.log('[StandaloneMealAnalysis] Saved meal using RPC fallback');
          }
        } catch (rpcErr) {
          console.error('[StandaloneMealAnalysis] RPC fallback error:', rpcErr);
          throw new Error(`Failed to save meal: ${error.message}`);
        }
      } else {
        console.log('[StandaloneMealAnalysis] Meal saved successfully');
      }
      
      // Also save to localStorage for redundancy
      try {
        const storageKey = `meal_analysis_${mealId}`;
        localStorage.setItem(storageKey, JSON.stringify({
          ...mealEntry,
          timestamp: Date.now()
        }));
        console.log('[StandaloneMealAnalysis] Meal also saved to localStorage');
      } catch (e) {
        console.warn('[StandaloneMealAnalysis] Could not save to localStorage:', e);
      }
      
      setSaveSuccess(true);
      
      // Clear success message after 3 seconds
      setTimeout(() => {
        setSaveSuccess(false);
      }, 3000);
    } catch (err) {
      console.error('Error saving meal to history:', err);
      setSaveError(err instanceof Error ? err.message : 'Failed to save meal to history');
    } finally {
      setIsSaving(false);
    }
  };
  
  // Process nutrient information to add descriptions
  useEffect(() => {
    if (mealData && mealData.analysis) {
      // Get the effective profile for personalization
      const profile = getEffectiveProfile(userProfile);
      
      // Make a deep copy of the meal data to avoid modifying the original
      const updatedMealData = JSON.parse(JSON.stringify(mealData));
      
      // Add descriptions to macronutrients if missing and apply personalized DV
      if (updatedMealData.analysis.macronutrients) {
        updatedMealData.analysis.macronutrients.forEach((macro: Nutrient) => {
          // Add description if missing
          if (!macro.description && macro.name) {
            const lowerName = macro.name.toLowerCase();
            macro.description = NUTRIENT_DESCRIPTIONS[lowerName] || 
              `${macro.name} is an important macronutrient essential for bodily functions.`;
          }
          
          // Apply personalized daily value if profile exists
          if (profile && macro.amount) {
            const personalizedDV = calculatePersonalizedDV(macro, profile);
            if (personalizedDV > 0) {
              macro.percentDailyValue = personalizedDV;
            }
          }
        });
      }
      
      // Add descriptions to micronutrients if missing and apply personalized DV
      if (updatedMealData.analysis.micronutrients) {
        updatedMealData.analysis.micronutrients.forEach((micro: Nutrient) => {
          if (!micro.description && micro.name) {
            const lowerName = micro.name.toLowerCase();
            micro.description = NUTRIENT_DESCRIPTIONS[lowerName] || 
              `${micro.name} is an important micronutrient that supports various bodily functions.`;
          }
          
          // Apply personalized daily value if profile exists
          if (profile && micro.amount) {
            const personalizedDV = calculatePersonalizedDV(micro, profile);
            if (personalizedDV > 0) {
              micro.percentDailyValue = personalizedDV;
            }
          }
        });
      }
      
      // Update the meal data state
      setMealData(updatedMealData);
    }
  }, [userProfile, mealData?.id]);
  
  // Fetch meal data from API or localStorage
  const fetchMealData = async () => {
    if (!mealId) {
      console.error('[StandaloneMealAnalysis] No meal ID provided for fetching');
      return;
    }
    
    try {
      setIsLoading(true);
      console.log(`[StandaloneMealAnalysis] Fetching meal data for ID: ${mealId}`);
      
      // Try localStorage first (fastest)
      if (typeof window !== 'undefined') {
        try {
          const localData = localStorage.getItem(`meal_${mealId}`);
          if (localData) {
            const parsedData = JSON.parse(localData);
            console.log('[StandaloneMealAnalysis] Found meal data in localStorage');
            setMealData(normalizeData(parsedData));
            setIsLoading(false);
            return;
          }
        } catch (e) {
          console.warn('[StandaloneMealAnalysis] Error reading from localStorage:', e);
        }
      }
      
      // Try the API - first try status check endpoint
      const statusResponse = await fetch(`/api/analyze-meal?id=${mealId}&statusOnly=true`, {
        credentials: 'include'
      });
      
      if (statusResponse.ok) {
        const statusResult = await statusResponse.json();
        
        // If still processing, start polling
        if (statusResult.status === 'processing') {
          console.log('[StandaloneMealAnalysis] Meal analysis still processing, starting polling');
          setIsProcessing(true);
          startPolling();
          return;
        }
      }
      
      // Try full meal data endpoint
      const response = await fetch(`/api/meals/${mealId}`, {
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error(`Failed to fetch meal data. Status: ${response.status}`);
      }
      
      const result = await response.json();
      
      if (result.success && result.data) {
        console.log('[StandaloneMealAnalysis] Successfully fetched meal data from API');
        
        // Process and save the data
        const normalizedData = normalizeData(result.data);
        setMealData(normalizedData);
        
        // Cache in localStorage for future requests
        if (typeof window !== 'undefined') {
          try {
            localStorage.setItem(`meal_${mealId}`, JSON.stringify(normalizedData));
          } catch (e) {
            console.warn('[StandaloneMealAnalysis] Failed to cache data in localStorage:', e);
          }
        }
      } else {
        throw new Error(result.error || 'Failed to fetch meal data');
      }
    } catch (error) {
      console.error('[StandaloneMealAnalysis] Error fetching meal data:', error);
      setError(error instanceof Error ? error.message : 'Failed to load meal analysis');
      
      // Try to use fallback data if we have any
      if (typeof window !== 'undefined') {
        try {
          if (mealId) {
            const fallbackData = localStorage.getItem(`meal_fallback_${mealId}`);
            if (fallbackData) {
              const parsedData = JSON.parse(fallbackData);
              console.log('[StandaloneMealAnalysis] Using fallback data');
              setMealData(normalizeData(parsedData));
            }
          }
        } catch (e) {
          console.error('[StandaloneMealAnalysis] Error using fallback data:', e);
        }
      }
    } finally {
      setIsLoading(false);
    }
  };
  
  // Start polling for meal status updates
  const startPolling = () => {
    if (pollingInterval.current) {
      clearInterval(pollingInterval.current);
    }
    
    // Poll every 3 seconds
    pollingInterval.current = setInterval(async () => {
      try {
        const currentMealId = mealIdRef.current;
        if (!currentMealId) return;
        
        // Check status with the status-only endpoint
        const statusResponse = await fetch(`/api/analyze-meal?id=${currentMealId}&statusOnly=true`);
        
        if (!statusResponse.ok) {
          console.warn(`[StandaloneMealAnalysis] Status polling response not OK: ${statusResponse.status}`);
          return;
        }
        
        const statusResult = await statusResponse.json();
        
        // If not processing anymore, try to get full data
        if (statusResult.status !== 'processing') {
          console.log('[StandaloneMealAnalysis] Processing complete, fetching full data');
          
          // Stop polling and fetch full data
          if (pollingInterval.current) {
            clearInterval(pollingInterval.current);
            pollingInterval.current = null;
          }
          
          setIsProcessing(false);
          
          // Get the full meal data
          const fullDataResponse = await fetch(`/api/meals/${currentMealId}`, {
            credentials: 'include'
          });
          
          if (fullDataResponse.ok) {
            const result = await fullDataResponse.json();
            
            if (result.success && result.data) {
              const normalizedData = normalizeData(result.data);
              setMealData(normalizedData);
              
              // Cache in localStorage for future requests
              try {
                localStorage.setItem(`meal_${currentMealId}`, JSON.stringify(normalizedData));
              } catch (e) {
                console.warn('[StandaloneMealAnalysis] Failed to cache data in localStorage:', e);
              }
            }
          }
        } else {
          // Still processing, update progress
          setProcessingProgress(statusResult.progress || 0);
          setProcessingMessage(statusResult.message || 'Processing your meal analysis...');
        }
      } catch (pollingError) {
        console.error('[StandaloneMealAnalysis] Polling error:', pollingError);
      }
    }, 3000);
  };
  
  // Render meal image
  const renderMealImage = () => {
    if (!mealData || !mealData.imageUrl) {
      return null;
    }
    
    return (
      <div className="relative rounded-lg overflow-hidden bg-gray-900 shadow-lg mb-6">
      <MealImage 
        src={mealData.imageUrl} 
          alt={mealData.mealName || 'Analyzed meal'} 
          className="w-full h-auto object-cover"
        />
        <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-4">
          <h1 className="text-2xl md:text-3xl font-bold text-white">{mealData.mealName || 'Analyzed Meal'}</h1>
          {mealData.goal && (
            <div className="flex items-center mt-2">
              <span className="text-xs bg-indigo-900/50 text-indigo-200 px-2 py-1 rounded-full">
                {mealData.goal}
              </span>
        </div>
          )}
        </div>
      </div>
    );
  };
  
  // Render nutrient analysis
  const renderNutrientAnalysis = () => {
    if (!mealData) {
      return <div className="p-4 text-gray-400">No meal data available</div>;
    }
    
    // Ensure analysis object exists
    const analysis = mealData.analysis || {
      calories: mealData.calories || 0,
      macronutrients: mealData.macronutrients || [],
      micronutrients: mealData.micronutrients || []
    };
    
    return (
      <div className="space-y-8">
        {/* Meal description */}
        {mealData.mealDescription && (
          <div className="bg-gray-800/60 rounded-lg p-4 mb-6">
            <p className="text-gray-300">{mealData.mealDescription}</p>
          </div>
        )}
            
        {/* Calories */}
        <div className="bg-indigo-900/30 border border-indigo-800/50 rounded-lg p-6">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-semibold text-indigo-300">Nutritional Analysis</h2>
            <div className="text-2xl font-bold text-indigo-100">
              {analysis.calories || analysis.totalCalories || mealData.calories || 0} <span className="text-sm text-indigo-300">kcal</span>
            </div>
          </div>
          
          {/* Ingredients if available */}
          {mealData.ingredients && mealData.ingredients.length > 0 && (
            <div className="mb-6">
              <h3 className="text-md font-semibold text-indigo-300 mb-2">Ingredients</h3>
              <ul className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                {mealData.ingredients.map((ingredient, i) => (
                  <li key={i} className="flex justify-between text-sm bg-indigo-900/20 p-2 rounded-md">
                    <span className="text-gray-300">{ingredient.name}</span>
                    {ingredient.calories && (
                      <span className="text-indigo-300 ml-2">{ingredient.calories} kcal</span>
                    )}
                  </li>
                ))}
              </ul>
            </div>
          )}
          
          {/* Macronutrients */}
          {(analysis.macronutrients?.length > 0 || mealData.macronutrients?.length > 0) && (
            <div className="mb-6">
              <h3 className="text-md font-semibold text-indigo-300 mb-3">Macronutrients</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {(analysis.macronutrients || mealData.macronutrients).map((nutrient, index) => (
                  <EnhancedNutrientDisplay
                    key={index}
                    nutrient={nutrient}
                    userProfile={effectiveProfile}
                    showDescription={true}
                    highlightLevel={nutrient.name.toLowerCase() === 'protein' ? 'high' : 'normal'}
                  />
                ))}
              </div>
            </div>
          )}
      
          {/* Micronutrients */}
          {(analysis.micronutrients?.length > 0 || mealData.micronutrients?.length > 0) && (
            <div>
              <h3 className="text-md font-semibold text-indigo-300 mb-3">Micronutrients</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {(analysis.micronutrients || mealData.micronutrients).map((nutrient, index) => (
                  <EnhancedNutrientDisplay
                    key={index}
                    nutrient={nutrient}
                    userProfile={effectiveProfile}
                    showDescription={true}
                  />
                ))}
              </div>
            </div>
          )}
        </div>
      </div>
    );
  };
  
  // Render health review
  const renderHealthReview = () => {
    if (!mealData) {
      return null;
    }
    
    return (
      <AIHealthReview
        mealId={mealData.id || mealData.mealId}
        userProfile={effectiveProfile}
        benefits={mealData.benefits || []}
        concerns={mealData.concerns || []}
        suggestions={mealData.suggestions || []}
        goal={mealData.goal || 'General Health'}
        insights={mealData.insights || ''}
      />
    );
  };
  
  // Render upload form
  const renderUploadForm = () => {
    return (
      <div className="max-w-3xl mx-auto">
        <div className="bg-gradient-to-br from-indigo-900/30 to-purple-900/30 rounded-lg border border-indigo-800/50 p-6 shadow-md">
          <h2 className="text-2xl font-bold text-indigo-300 mb-6 text-center">Analyze Your Meal</h2>
          
          {error && (
            <div className="bg-red-900/20 border border-red-800/40 text-red-300 p-3 rounded-md mb-6">
              <div className="flex items-start">
                <AlertCircle className="w-5 h-5 mr-2 mt-0.5 flex-shrink-0" />
                <p>{error}</p>
                        </div>
                      </div>
          )}
          
          <div className="space-y-6">
            {/* Meal name input */}
            <div>
              <label htmlFor="mealName" className="block text-indigo-300 font-medium mb-2">
                Meal Name
              </label>
              <input
                type="text"
                id="mealName"
                value={mealName}
                onChange={(e) => setMealName(e.target.value)}
                className="w-full bg-gray-800 border border-gray-700 text-gray-200 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                placeholder="Enter a name for this meal"
              />
                  </div>
                  
            {/* Health goal selection */}
            <div>
              <label htmlFor="goal" className="block text-indigo-300 font-medium mb-2">
                Health Goal
              </label>
              <select
                id="goal"
                value={mealGoal}
                onChange={(e) => setMealGoal(e.target.value)}
                className="w-full bg-gray-800 border border-gray-700 text-gray-200 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              >
                <option value="General Health">General Health</option>
                <option value="Weight Loss">Weight Loss</option>
                <option value="Muscle Gain">Muscle Gain</option>
                <option value="Heart Health">Heart Health</option>
                <option value="Diabetes Management">Diabetes Management</option>
                <option value="Energy Boost">Energy Boost</option>
                <option value="Improved Digestion">Improved Digestion</option>
              </select>
                          </div>
            
            {/* Image upload area */}
            <div>
              <label className="block text-indigo-300 font-medium mb-2">
                Meal Image
              </label>
              <div
                {...getRootProps()}
                className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors ${
                  isDragActive ? 'border-indigo-500 bg-indigo-900/20' : 'border-gray-700 hover:border-indigo-500 hover:bg-indigo-900/10'
                }`}
              >
                <input {...getInputProps()} />
                
                {previewUrl ? (
                  <div className="space-y-4">
                    <img
                      src={previewUrl}
                      alt="Selected meal"
                      className="max-h-64 mx-auto rounded-md"
                    />
                    <p className="text-gray-400">
                      Click or drag to change image
                    </p>
                          </div>
                ) : (
                  <div className="space-y-2">
                    <Camera className="w-12 h-12 text-indigo-500 mx-auto" />
                    <p className="text-gray-300">
                      Drag and drop an image here, or click to select a file
                    </p>
                    <p className="text-gray-400 text-sm">
                      For best results, use a clear, well-lit photo of your meal
                    </p>
                </div>
              )}
                  </div>
                        </div>
            
            {/* Reset form button */}
            <div className="flex justify-center">
              <button
                onClick={resetForm}
                className="flex items-center justify-center px-4 py-2 text-sm font-medium text-gray-600 bg-gray-100 border border-gray-300 rounded-md shadow-sm hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
              >
                Reset Form
              </button>
            </div>
            
            {/* Analyze button */}
            <button
              onClick={analyzeImage}
              className="w-full flex items-center justify-center px-4 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
              disabled={isLoading || !file}
            >
              {isLoading ? (
                <>
                  <LoadingSpinner size="medium" className="mb-4" />
                  Analyzing...
                </>
              ) : (
                'Analyze Meal'
              )}
            </button>
          </div>
        </div>
      </div>
    );
  };
  
  // Hook to capture the mealId from URL if available
  useEffect(() => {
    // Track window object initialization
    if (typeof window !== 'undefined') {
      // Store current meal ID in window for debugging
      try {
        const pathParts = window.location.pathname.split('/');
        const analysisIndex = pathParts.indexOf('analysis');
        if (analysisIndex >= 0 && pathParts.length > analysisIndex + 1) {
          const urlMealId = pathParts[analysisIndex + 1];
          console.log('[StandaloneMealAnalysis] Found meal ID in URL:', urlMealId);
          window.currentMealId = urlMealId;
          
          // If we have a meal ID in the URL but not as a prop, update it
          if (urlMealId && !mealId) {
            console.log('[StandaloneMealAnalysis] Setting mealId from URL:', urlMealId);
            
            // Check if mealData exists in localStorage
            const localData = localStorage.getItem(`meal_${urlMealId}`);
            if (localData) {
              try {
                const parsedData = JSON.parse(localData);
                console.log('[StandaloneMealAnalysis] Found cached data for meal:', urlMealId);
                setMealData(ensureProperDataStructure(parsedData));
                setIsLoading(false);
              } catch (e) {
                console.error('[StandaloneMealAnalysis] Error parsing cached data:', e);
              }
            }
          }
        } else {
          console.log('[StandaloneMealAnalysis] No meal ID found in URL path');
        }
      } catch (e) {
        console.error('[StandaloneMealAnalysis] Error checking URL for meal ID:', e);
      }
      
      // Add helper function to force redirect
      window.forceRedirectToAnalysis = (mealId) => {
        if (mealId) {
          const url = `/analysis/${mealId}`;
          console.log(`[StandaloneMealAnalysis] Forcing redirect to: ${url}`);
          window.location.href = url;
          return true;
        }
        return false;
      };
    }
  }, [mealId]);
  
  // Main render
  if (embedded) {
    // Minimal view for embedded usage
    return (
      <div className="bg-gray-900 text-gray-200 p-4 rounded-lg">
        {isLoading ? (
          <div className="flex justify-center items-center p-12">
            <LoadingSpinner size="medium" color="blue" />
                      </div>
        ) : error ? (
          <div className="text-red-400 p-4">{error}</div>
        ) : analysisComplete && mealData ? (
          <div className="space-y-6">
            {renderMealImage()}
            {renderNutrientAnalysis()}
            {renderHealthReview()}
              </div>
        ) : (
          renderUploadForm()
        )}
                      </div>
    );
  }
  
  // Full page view
  return (
    <div className="bg-gray-900 min-h-screen text-gray-200">
      <div className="max-w-5xl mx-auto py-8 px-4">
        <div className="mb-6">
          <Link
            href="/"
            className="flex items-center text-indigo-400 hover:text-indigo-300 transition-colors"
          >
            <ChevronsLeft className="w-5 h-5 mr-1" />
            Back to Home
          </Link>
      </div>
      
        {isLoading ? (
          <div className="flex flex-col justify-center items-center p-12">
            <LoadingSpinner size="large" />
            <p className="mt-4 text-indigo-300 text-lg">Analyzing your meal...</p>
            <p className="text-gray-400 text-sm mt-2">This may take up to 20 seconds</p>
          </div>
        ) : error ? (
          <div className="bg-red-900/20 border border-red-800/40 text-red-300 p-6 rounded-lg">
            <h2 className="text-xl font-bold mb-2">Error</h2>
            <p>{error}</p>
            <button
              onClick={resetForm}
              className="mt-4 px-4 py-2 bg-gray-800 hover:bg-gray-700 rounded-md flex items-center"
            >
              <ArrowLeft className="w-4 h-4 mr-2" />
              Try Again
            </button>
        </div>
        ) : analysisComplete && mealData ? (
          <div className="space-y-6">
            {renderMealImage()}
            {renderNutrientAnalysis()}
            {renderHealthReview()}
            
            {/* Action buttons */}
            <div className="flex flex-wrap gap-4 mt-8">
              <button
                onClick={resetForm}
                className="px-4 py-2 bg-gray-800 hover:bg-gray-700 rounded-md flex items-center"
              >
                <Upload className="w-4 h-4 mr-2" />
                Analyze Another Meal
              </button>
              
              {user && (
            <button 
                  onClick={saveMealToHistory}
                  disabled={isSaving || saveSuccess}
                  className={`px-4 py-2 rounded-md flex items-center ${
                    isSaving || saveSuccess
                      ? 'bg-green-800/50 text-green-300 cursor-not-allowed'
                      : 'bg-green-800/30 hover:bg-green-700/50 text-green-300'
                  }`}
                >
                  {isSaving ? (
                    <>
                      <LoadingSpinner size="small" className="mr-2" />
                      Saving...
                    </>
                  ) : saveSuccess ? (
                    <>
                      <CheckCircle className="w-4 h-4 mr-2" />
                      Saved!
                    </>
                  ) : (
                    <>
                      <History className="w-4 h-4 mr-2" />
                      Save to My History
                    </>
                  )}
            </button>
              )}
            </div>
            
            {/* Save error message */}
            {saveError && (
              <div className="bg-red-900/20 border border-red-800/40 text-red-300 p-3 rounded-md mt-4">
                <p>{saveError}</p>
          </div>
            )}
        </div>
        ) : (
          renderUploadForm()
        )}
      </div>
    </div>
  );
}

// Helper function to normalize data from different sources
const normalizeData = (data: any) => {
  // If the data is properly formatted, return it as is
  if (data.mealAnalysis && data.mealAnalysis.macronutrients) {
    return data;
  }
  
  const normalized: any = {
    mealId: data.id || data.uuid || data.mealId,
    mealName: data.name || data.meal_name || data.caption || data.mealName || 'Meal Analysis',
    imageUrl: data.image_url || data.imageUrl,
    goal: data.goal || 'General Health',
    mealAnalysis: {}
  };
  
  // Handle different data structures
  if (data.analysis) {
    // If analysis is a nested object
    normalized.mealAnalysis = {
      ...data.analysis,
      calories: data.calories || (data.analysis.calories || 0),
      macronutrients: data.macronutrients || data.analysis.macronutrients || [],
      micronutrients: data.micronutrients || data.analysis.micronutrients || [],
      benefits: data.benefits || data.analysis.benefits || [],
      concerns: data.concerns || data.analysis.concerns || [],
      suggestions: data.suggestions || data.analysis.suggestions || [],
      insights: data.insights || (data.analysis.insights) || null
    };
  } else if (data.mealAnalysis) {
    // Data already has mealAnalysis structure
    normalized.mealAnalysis = data.mealAnalysis;
  } else {
    // Data is flat, collect all fields
    normalized.mealAnalysis = {
      calories: data.calories || 0,
      macronutrients: data.macronutrients || [],
      micronutrients: data.micronutrients || [],
      benefits: data.benefits || [],
      concerns: data.concerns || [],
      suggestions: data.suggestions || [],
      insights: data.insights || null
    };
  }
  
  // Ensure we have an insights field if possible
  if (!normalized.mealAnalysis.insights) {
    normalized.mealAnalysis.insights = data.insights || null;
  }
  
  // Ensure we have other required fields
  normalized.timestamp = data.created_at || data.timestamp || new Date().toISOString();
  normalized.tags = data.tags || [];
  
  return normalized;
};

// Helper function to ensure proper data structure
const ensureProperDataStructure = (data: any) => {
  if (!data) return null;
  
  // Create a normalized structure
  const normalized: any = {
    id: data.id || data.mealId || data.uuid || 'unknown-id',
    mealId: data.id || data.mealId || data.uuid || 'unknown-id',
    mealName: data.mealName || data.meal_name || data.name || 'Analyzed Meal',
    imageUrl: data.imageUrl || data.image_url || '',
    goal: data.goal || 'General Health',
    calories: data.calories || 0,
    
    // Ensure these critical arrays exist
    macronutrients: data.macronutrients || (data.analysis?.macronutrients) || [],
    micronutrients: data.micronutrients || (data.analysis?.micronutrients) || [],
    benefits: data.benefits || (data.analysis?.benefits) || [],
    concerns: data.concerns || (data.analysis?.concerns) || [],
    suggestions: data.suggestions || (data.analysis?.suggestions) || [],
    insights: data.insights || (data.analysis?.insights) || '',
    
    // Always include an analysis object with proper structure
    analysis: {
      calories: data.calories || (data.analysis?.calories) || 0,
      totalCalories: data.totalCalories || (data.analysis?.totalCalories) || data.calories || 0,
      macronutrients: data.macronutrients || (data.analysis?.macronutrients) || [],
      micronutrients: data.micronutrients || (data.analysis?.micronutrients) || []
    }
  };
  
  return normalized;
}; 